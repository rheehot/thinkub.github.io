<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>개인 저장소</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-25T07:35:29.139Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker - 8. Image 저장소</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%208.%20Image%20%EC%A0%80%EC%9E%A5%EC%86%8C/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%208.%20Image%20%EC%A0%80%EC%9E%A5%EC%86%8C/</id>
    <published>2020-02-25T06:55:57.810Z</published>
    <updated>2020-02-25T07:35:29.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h1><p>지금까지 Docker에 대한 개념과 Container 구동방법 그리고 Image를 만드는 방법등을 살펴봤습니다.<br>이번엔 생성한 Image를 저장하고 저장된 Image를 원격에서 Pull받아서 사용할 수 있는 저장소에 대해 알아보겠습니다.</p><ol><li>Docker Hub</li><li>GitLab Container Registry</li><li>Docker Registry</li></ol><p><strong>여기서는 Docker Hub 와 GitLab Container Registry 에 대해 알아보겠습니다.</strong><br><strong>참고로 저희는 GitLab Container Registry 사용하는 방향으로 셋팅중 입니다.</strong></p><h1 id="1-Docker-Hub"><a href="#1-Docker-Hub" class="headerlink" title="1. Docker Hub"></a>1. Docker Hub</h1><p>Docker Hub는 컨테이너 이미지를위한 세계 최대의 라이브러리 및 커뮤니티입니다.<br>Docker에서 공식으로 지원하는 Repositry로 공개 Image저장소 이기도 합니다.<br>물론 약간(?) 의 비용을 지불하면 private Repository를 사용 할 수 있습니다.<br>Docker Hub에서 private Repository를 만들어 보겠습니다.</p><h3 id="1-1-Repository-생성"><a href="#1-1-Repository-생성" class="headerlink" title="1.1 Repository 생성"></a>1.1 Repository 생성</h3><ul><li>Repository 명칭을 적습니다. (broker-api로 하겠습니다.)</li><li>Repository 는 Private으로 생성하겠습니다.</li><li>Autobuild 가 지원이 됩니다. (GitHub, Bitbucket)<ul><li>GitHub과 Bitbucket를 사용하기 않기 때문에 다루지 않겠습니다.</li></ul></li></ul><p><img src="/img/2020/02/25/48.png" alt="image48"></p><p><strong>정상적으로 Repository 가 생성된 것을 확인 할 수 있습니다.</strong></p><p><img src="/img/2020/02/25/49.png" alt="image49"></p><h3 id="1-2-Image-Push"><a href="#1-2-Image-Push" class="headerlink" title="1.2 Image Push"></a>1.2 Image Push</h3><ul><li><p>생성된 Docker Hub Repository 에 Image Push를 해보겠습니다.</p><ul><li>docker login 명령어로 docker hub 계정로그인을 진행합니다.</li><li>docker pull 명령어로 생성된 이미지를 docker hub에 pull 합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login</span><br><span class="line">sudo docker push thinkub/broker-api:0.0.1</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/50.png" alt="image50"></li></ul></li><li><p>정상적으로 pull이 되었는지 확인해봅니다.</p></li></ul><p><img src="/img/2020/02/25/51.png" alt="image51"></p><h3 id="1-3-Image-pull"><a href="#1-3-Image-pull" class="headerlink" title="1.3 Image pull"></a>1.3 Image pull</h3><ul><li>Docker Hub Repository에 있는 Image를 pull 받아보겠습니다.</li><li><code>생성한 Repository 는 private Repository이기 때문에 docker login 이후에 pull을 받을 수 있습니다.</code></li></ul><p><img src="/img/2020/02/25/52.png" alt="image52"></p><h1 id="2-GitLab-Container-Registry"><a href="#2-GitLab-Container-Registry" class="headerlink" title="2. GitLab Container Registry"></a>2. GitLab Container Registry</h1><p>GitLab에서도 <strong>Container Registry</strong>라는 Docker Image 저장소를 제공하고 있습니다.<br>GitLab 설치시 Default 설정이 되지 않으므로 활성화를 해야 합니다.<br>관련 문서는 <a href="https://docs.gitlab.com/ce/administration/packages/container_registry.html" target="_blank" rel="noopener">이곳</a> 을 참고해주세요.</p><p><code>컨테이너 레지스트리는 기본적으로 HTTPS에서 작동합니다. HTTPS 설정을 선행한 후 진행해주세요</code><br><code>해당 문서는 gitlab이 이미 설치된 상태에서의 작업입니다.</code></p><h3 id="2-1-Registry-Container-활성화"><a href="#2-1-Registry-Container-활성화" class="headerlink" title="2.1 Registry Container 활성화"></a>2.1 Registry Container 활성화</h3><ul><li><p>/etc/gitlab/gitlab.rb 설정파일을 수정합니다.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># registry 에서 사용하는 주소로 gitlab주소에서 8929 Port를 사용하도록 설정</span></span><br><span class="line"><span class="comment"># port는 필요에의해서 변경 할 수 있음.</span></span><br><span class="line">registry_external_url <span class="string">'https://....:8929'</span></span><br><span class="line"></span><br><span class="line">gitlab_rails[<span class="string">'registry_enabled'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'registry_path'</span>] = <span class="string">"/var/opt/gitlab/gitlab-rails/shared/registry"</span></span><br><span class="line"></span><br><span class="line">registry[<span class="string">'enable'</span>] = <span class="literal">true</span></span><br><span class="line">registry[<span class="string">'registry_http_addr'</span>] = <span class="string">"localhost:5001"</span></span><br><span class="line"></span><br><span class="line">registry_nginx[<span class="string">'ssl_certificate'</span>] = <span class="string">"/etc/gitlab/ssl/Wildcard.ziny.us.crt"</span></span><br><span class="line">registry_nginx[<span class="string">'ssl_certificate_key'</span>] = <span class="string">"/etc/gitlab/ssl/Wildcard.ziny.us.key"</span></span><br></pre></td></tr></table></figure></li><li><p>gitlab 재설정</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li><li><p>Container Registry 접속 확인</p></li></ul><p><img src="/img/2020/02/25/53.png" alt="image53"></p><h3 id="2-2-Container-Registry-접근"><a href="#2-2-Container-Registry-접근" class="headerlink" title="2.2 Container Registry 접근"></a>2.2 Container Registry 접근</h3><p>활성화 된 Registry 에 접근해 보겠습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login [url]:[port]</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/54.png" alt="image54"><br><code>certificate signed by unknown authority</code> 라는 오류가 발생합니다.</p><p><strong>Docker hostname을 port와 같이 사용하는경우 어떤 인증서를 사용해야할지 추측하지 않습니다.</strong><br><strong>이를 위해서 <code>/etc/docker/certs.d/{hostname:port}/</code> 폴더를 생성한 후 해당 폴더에 인증서를 저장해두어야 합니다.</strong></p><h4 id="gitlab인증서를-복사합니다"><a href="#gitlab인증서를-복사합니다" class="headerlink" title="gitlab인증서를 복사합니다."></a>gitlab인증서를 복사합니다.</h4><p><img src="/img/2020/02/25/55.png" alt="image55"></p><h4 id="gitlab-container-registry-login-해봅니다"><a href="#gitlab-container-registry-login-해봅니다" class="headerlink" title="gitlab container registry login 해봅니다."></a>gitlab container registry login 해봅니다.</h4><p><img src="/img/2020/02/25/56.png" alt="image56"></p><h3 id="2-3-Container-Registry-에-Image-push-해보기"><a href="#2-3-Container-Registry-에-Image-push-해보기" class="headerlink" title="2.3 Container Registry 에 Image push 해보기"></a>2.3 Container Registry 에 Image push 해보기</h3><ul><li>기존에 생성된 broker-api 를 push 해볼 예정입니다.</li><li>container registry project 에 맞게 tag 작업을 합니다. (tag 규칙은 아래와 같습니다)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[HOST_NAME]/[PROJECT_NAME]:[TAG] 또는</span><br><span class="line">[HOST_NAME]/[GROUP_NAME]/[PROJECT_NAME]:[TAG]</span><br><span class="line"></span><br><span class="line">ex) </span><br><span class="line">sudo docker tag broker-api [url]:[port]/ai-labs-aip/broker-api:0.0.1</span><br></pre></td></tr></table></figure></li><li>push 명령어는 다음과 같습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push [url]:[port]/ai-labs-aip/broker-api</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/2020/02/25/57.png" alt="image57"></p><ul><li>정상적으로 Push 된지 확인해 봅니다.</li></ul><p><img src="/img/2020/02/25/58.png" alt="image58"></p><h3 id="2-4-Container-Registry에서-Image-Pull-받아서-Container-구동해보기"><a href="#2-4-Container-Registry에서-Image-Pull-받아서-Container-구동해보기" class="headerlink" title="2.4 Container Registry에서 Image Pull 받아서 Container 구동해보기"></a>2.4 Container Registry에서 Image Pull 받아서 Container 구동해보기</h3><ul><li>Container Registry 에서 Image 를 받아보겠습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull [url]:[port]/ai-labs-aip/broker-api:0.0.1</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/2020/02/25/59.png" alt="image59"></p><ul><li>Pull 받은 Image로 Container를 구동해보겠습니다.</li></ul><p><img src="/img/2020/02/25/60.png" alt="image60"></p><ul><li>접속 확인</li></ul><p><img src="/img/2020/02/25/61.png" alt="image61"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 7. Docker Compose</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%207.%20Docker%20Compose/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%207.%20Docker%20Compose/</id>
    <published>2020-02-25T06:51:32.639Z</published>
    <updated>2020-02-25T07:18:20.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Docker Compose는 <strong>다중 Container Application을 정의하고 실행하기 위한 도구</strong>입니다.<br>YAML파일을 사용하여 Application 서비스를 구성합니다.<br>예를 들어 Application 을 구동하기 위해 DB 설치를 하고, Application 구동 해야 한다면<br>DB 용 Container를 구성하고 Application용 Container를 구성해야 합니다. 이러한 구성을 Compose를 이용한다면<br>YAML로 작성된 설정파일 1개로 구성이 가능합니다.</p><p>Compose는 3단계 프로세스가 작동합니다.</p><ol><li>Dockerfile로 환경을 정의함</li><li>docker-compose.yml에서 앱을 구성하는 서비스를 정의하여 격리된 환경에서 함께 실행 될 수 있도록 함.</li><li>docker-compose up을 실행하면 Compose가 전체 앱을 시작하고 실행</li></ol><p>관련 문서는 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">여기</a>를 참고해주세요</p><h1 id="1-Docker-Compose-설치"><a href="#1-Docker-Compose-설치" class="headerlink" title="1.Docker Compose 설치"></a>1.Docker Compose 설치</h1><p>간단하게 아래 명령어로 설치가 가능합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/44.png" alt="image44"></p><h1 id="2-Docker-Compose로-Container구동하기"><a href="#2-Docker-Compose로-Container구동하기" class="headerlink" title="2.Docker Compose로 Container구동하기"></a>2.Docker Compose로 Container구동하기</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">이번에 진행할 Sample 역시 broker-api 입니다.</span><br><span class="line">broker-api개발시 vision연동 데이터를 저장히가 위해 mongo-db 를 설치 했었습니다.</span><br><span class="line">docker-compose로 mongodb 와 broker-api 를 container구동해보도록 하겠습니다.</span><br></pre></td></tr></table></figure><h3 id="2-1-yaml-파일을-작성"><a href="#2-1-yaml-파일을-작성" class="headerlink" title="2-1. yaml 파일을 작성"></a>2-1. yaml 파일을 작성</h3><ul><li>version : docker compose 버전을 작성, 버전에 따라 지원하는 옵션이 달라집니다(관련 내용은 <a href="https://docs.docker.com/compose/compose-file/compose-versioning/" target="_blank" rel="noopener">공식문서</a> 참고)</li><li>services: container들을 정의합니다.</li><li>image: docker image를 적습니다. local에 있는 image라면 local image를 사용하고 없는 image라면 docker hub의 공식 이미지를 다운받아집니다.</li><li>restart: 서버 재시작시 container의 자동재시작 여부</li><li>port: docker run 명령의 -p 옵션</li><li>volumes: docker run 명령의 -v 옵션</li><li>container_name: 실행하는 container 명칭</li><li>environment: 환경변수<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'broker-api2'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'18080:18080'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'/home/ces/logs:/home/thinkub0219/log'</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">"broker-api2"</span></span><br><span class="line">  <span class="attr">mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'mongo'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_DATABASE:</span> <span class="string">vision</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="string">P@ssw0rd</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'./db:/home/thinkub0219/db'</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">"mongodb"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"27017:27017"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-docker-compose-실행"><a href="#2-2-docker-compose-실행" class="headerlink" title="2.2 docker compose 실행"></a>2.2 docker compose 실행</h3><p>docker compose를 실행하게되면 yaml파일에 정의된 내용이 실행이 됩니다.<br>container 까지 실행이 됩니다.<br><code>docker-compose.yml 파일이 있는 경로에서 실행해야 합니다.</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/45.png" alt="image45"></p><h1 id="3-작동확인"><a href="#3-작동확인" class="headerlink" title="3. 작동확인"></a>3. 작동확인</h1><ul><li>broker-api</li></ul><p><img src="/img/2020/02/25/46.png" alt="image46"></p><ul><li>mongodb</li></ul><p><img src="/img/2020/02/25/47.png" alt="image47"></p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 6. Dockerfile</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%206.%20Dockerfile/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%206.%20Dockerfile/</id>
    <published>2020-02-25T06:37:25.066Z</published>
    <updated>2020-02-25T07:18:19.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="Dockerfile-기본명령어"><a href="#Dockerfile-기본명령어" class="headerlink" title="Dockerfile 기본명령어"></a>Dockerfile 기본명령어</h1><blockquote><p>Dockerfile은 Docker Image를 생성하기위해 DSL언어로 구성된 파일입니다.</p></blockquote><p>Dockerfile 관련 reference 문서는 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">이곳</a> 을 참고하시면 됩니다.</p><h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">FROM centos:centos7.7.1908</span><br></pre></td></tr></table></figure><p>Base Image를 지정합니다. <code>필수값</code>으로 어떤 Image도 Base Image가 될 수 있습니다.<br>tag는 될 수 있으면 기본값(lastest) 보다 구체적인 버전을 지정하는것이 좋습니다.</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br><span class="line">MAINTAINER mhlee@saltlux.com</span><br></pre></td></tr></table></figure><p>파일 관리자의 이름 또는 Email정보를 적습니다. </p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY . /usr/src/app</span><br></pre></td></tr></table></figure><p>파일이나 디렉토리를 이미지로 복사합니다.<br>일반적으로 소스를 복사하는 데 사용합니다.<br><code>target</code> 디렉토리가 없다면 자동으로 생성합니다.</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD . /usr/src/app</span><br></pre></td></tr></table></figure><p>COPY명령어와 매우 유사하나 몇가지 추가 기능이 있습니다.<br>src에 파일 대신 URL을 입력할 수 있고 src에 압축 파일을 입력하는 경우 자동으로 압축을 해제하면서 복사됩니다.</p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">RUN bundle install</span><br></pre></td></tr></table></figure><p>가장 많이 사용하는 구문입니다. 명령어를 그대로 실행합니다.<br>내부적으로 /bin/sh -c 뒤에 명령어를 실행하는 방식입니다.</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2</span><br><span class="line">CMD bundle exec ruby app.rb</span><br></pre></td></tr></table></figure><p>도커 컨테이너가 실행되었을 때 실행되는 명령어를 정의합니다.<br>빌드할 때는 실행되지 않으며 여러 개의 CMD가 존재할 경우 가장 마지막 CMD만 실행됩니다.<br>한꺼번에 여러 개의 프로그램을 실행하고 싶은 경우에는 run.sh파일을 작성하여 데몬으로 실행하거나 supervisord나 forego와 같은 여러 개의 프로그램을 실행하는 프로그램을 사용합니다.</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure><p>RUN, CMD, ADD, COPY등이 이루어질 기본 디렉토리를 설정합니다.<br>각 명령어의 현재 디렉토리는 한 줄 한 줄마다 초기화되기 때문에 RUN cd /path를 하더라도 다음 명령어에선 다시 위치가 초기화 됩니다.<br>같은 디렉토리에서 계속 작업하기 위해서 WORKDIR을 사용합니다.</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line">EXPOSE 4567</span><br></pre></td></tr></table></figure><p>도커 컨테이너가 실행되었을 때 요청을 기다리고 있는(Listen) 포트를 지정합니다. 여러개의 포트를 지정할 수 있습니다.</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure><p>컨테이너 외부에 파일시스템을 마운트 할 때 사용합니다. 반드시 지정하지 않아도 마운트 할 수 있지만, 기본적으로 지정하는 것이 좋습니다.</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">ENV DB_URL mysql</span><br></pre></td></tr></table></figure><p>컨테이너에서 사용할 환경변수를 지정합니다. 컨테이너를 실행할 때 -e옵션을 사용하면 기존 값을 오버라이딩 하게 됩니다.</p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 5. Image 만들기</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%205.%20Image%20%EB%A7%8C%EB%93%A4%EA%B8%B0/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%205.%20Image%20%EB%A7%8C%EB%93%A4%EA%B8%B0/</id>
    <published>2020-02-25T06:24:39.997Z</published>
    <updated>2020-02-25T07:18:18.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h1><p>이번엔 Docker Image를 직접 만들어 보도록 하겠습니다.<br>Image를 만드는 방법은 2가지가 있습니다. (제가 아는 바로는)</p><ol><li><strong>베이스 이미지 (Os만 설치된 Container)를 만들어 놓고 Container에서 필요한 작업을 한 뒤 container commit으로 Image 생성</strong></li><li><strong>Dockerfile 을 이용한 Image생성</strong></li></ol><p>두 가지 케이스 다 실습해보도록 하겠습니다.<br>실습환경은 ces때 진행했던 broker-api 로 하겠습니다. </p><p><strong>설치순서</strong></p><ul><li>CentOS 설치</li><li>OpenJdk8 설치</li><li>application jar파일 다운로드</li><li>application start</li></ul><h1 id="1-Base-Image-OS-로-Container생성-후-commit-로-Image생성하기"><a href="#1-Base-Image-OS-로-Container생성-후-commit-로-Image생성하기" class="headerlink" title="1. Base Image(OS)로 Container생성 후 commit 로 Image생성하기."></a>1. Base Image(OS)로 Container생성 후 commit 로 Image생성하기.</h1><h3 id="1-1-CentOS-Image를-다운받습니다"><a href="#1-1-CentOS-Image를-다운받습니다" class="headerlink" title="1-1. CentOS Image를 다운받습니다."></a>1-1. CentOS Image를 다운받습니다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull centos</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/31.png" alt="image31"></p><h3 id="1-2-Container-생성하기"><a href="#1-2-Container-생성하기" class="headerlink" title="1-2. Container 생성하기"></a>1-2. Container 생성하기</h3><ul><li>-p 옵션으로 application 사용하는 18080포트 연결 목적</li><li>-v 옵션으로 application jar 파일 mount 목적<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd \</span><br><span class="line">-p 18080:18080 \</span><br><span class="line">-v /home/thinkub0219/webapp:/home/webapp \</span><br><span class="line">--name <span class="string">"centos"</span> centos</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/2020/02/25/32.png" alt="image32"></p><h3 id="1-3-Container-들어가기"><a href="#1-3-Container-들어가기" class="headerlink" title="1-3. Container 들어가기"></a>1-3. Container 들어가기</h3><ul><li>jdk 가 설치 되지 않은것을 확인 할 수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it centos /bin/bash</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/2020/02/25/33.png" alt="image33"></p><h3 id="1-4-Container-내부에-OpenJdk8-설치하기"><a href="#1-4-Container-내부에-OpenJdk8-설치하기" class="headerlink" title="1-4. Container 내부에 OpenJdk8 설치하기"></a>1-4. Container 내부에 OpenJdk8 설치하기</h3><ul><li>jdk 가 설치 된 것을 확인 할 수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum update -y; \</span><br><span class="line">yum install -y java-1.8.0-openjdk-devel.x86_64; \</span><br><span class="line">easy_install supervisor; \</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/34.png" alt="image34"></li></ul><h3 id="1-5-application-jar-다운로드"><a href="#1-5-application-jar-다운로드" class="headerlink" title="1-5. application jar 다운로드"></a>1-5. application jar 다운로드</h3><ul><li>현재 gitlab 환경이 내부망으로 컴파일 된 jar 파일 upload 처리함</li><li>정상 적인 case로는 git clone으로 source code download 후 build 처리하는 것을 추천함.</li><li>아래 이미지와 같이 mount 된 volume에 jar파일 upload 하면 docker 에 mount된 경로에서 확인이 가능함.</li></ul><p><img src="/img/2020/02/25/35.png" alt="image35"></p><h3 id="1-6-application-start"><a href="#1-6-application-start" class="headerlink" title="1-6. application start"></a>1-6. application start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -Dspring.profiles.active=dev -jar broker-api.jar &amp;</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/36.png" alt="image36"></p><h3 id="1-7-application-구동-확인"><a href="#1-7-application-구동-확인" class="headerlink" title="1-7. application 구동 확인"></a>1-7. application 구동 확인</h3><p>정상적으로 구동된 것을 확인 할 수 있습니다.</p><p><img src="/img/2020/02/25/37.png" alt="image37"></p><h3 id="1-8-image-생성하기"><a href="#1-8-image-생성하기" class="headerlink" title="1-8. image 생성하기"></a>1-8. image 생성하기</h3><p>정상적으로 구동된 것을 확인했으니, 해당 Container 기준으로 Image생성을 해보겠습니다.<br>새로 생성할 Image name 은 broker-api1 로 설정하겠습니다.<br>broker-api1이라는 image가 생성 된것을 확인 할 수 있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit centos broker-api1</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/38.png" alt="image38"></p><h3 id="1-9-생성된-image로-container-구동하기"><a href="#1-9-생성된-image로-container-구동하기" class="headerlink" title="1-9. 생성된 image로 container 구동하기."></a>1-9. 생성된 image로 container 구동하기.</h3><ul><li>기존 생성된 container를 삭제합니다.</li><li>생성된 image를 이용해 container를 구동합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd \</span><br><span class="line">-p 18080:18080 \</span><br><span class="line">-v /home/thinkub0219/webapp:/home/webapp \</span><br><span class="line">--name <span class="string">"broker-api1"</span> broker-api1</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/2020/02/25/39.png" alt="image39"></p><h3 id="1-10-application-구동확인"><a href="#1-10-application-구동확인" class="headerlink" title="1-10. application 구동확인"></a>1-10. application 구동확인</h3><ul><li><code>확인해보면 정상적으로 구동되지 않은 것을 확인 할 수 있습니다.</code></li><li>이유는 application start가 되지 않았기 때문입니다. container내부 환경요인은 정상 설치가 되었습니다.</li><li>application 구동을 진행하면 정상적으로 사이트 접근이 가능합니다.</li></ul><h1 id="2-Dockerfile-을-이용한-Image생성"><a href="#2-Dockerfile-을-이용한-Image생성" class="headerlink" title="2. Dockerfile 을 이용한 Image생성"></a>2. Dockerfile 을 이용한 Image생성</h1><p>이번엔 동일한 작업을 Dockerfile을 이용해서 Image생성을 해보겠습니다.<br>위 생성 방식은 나름 복잡(?) 하게 구성된 것에 비해 Dockerfile 생성 방식은 좀더 simple(?) 합니다.<br>Dockerfile에 대한 설명은 다음장에 설명하겠습니다.</p><h3 id="2-1-Dockerfile-작성"><a href="#2-1-Dockerfile-작성" class="headerlink" title="2-1. Dockerfile 작성"></a>2-1. Dockerfile 작성</h3><ul><li>centos 로 base image 를 지정한다.</li><li>작성자는 <a href="mailto:mhlee@saltlux.com" target="_blank" rel="noopener">mhlee@saltlux.com</a> 이다.</li><li>JAVA_HOME 환경변수를 지정한다.</li><li>openJdk를 설치한다.</li><li>source를 copy 한다 <code>(주의점은 container내부는 절대경로 지정이 가능하나 외부경로는 상대경로를 지정해줘야함)</code></li><li>port 설정을 한다</li><li>container 실행시 실행스크립트를 작성한다.<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> mhlee@saltlux.com</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/lib/jvm/java-openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Packages &amp; open jdk 1.9</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum update -y; \</span></span><br><span class="line"><span class="bash">    yum install -y java-1.8.0-openjdk-devel.x86_64; \</span></span><br><span class="line"><span class="bash">    easy_install supervisor; \</span></span><br><span class="line"><span class="bash">    yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source copy</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./webapp /home/webapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># app start</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">18080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> java -server -Dspring.profiles.active=dev -jar /home/webapp/broker-api.jar</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-Dockerfile-build"><a href="#2-2-Dockerfile-build" class="headerlink" title="2-2. Dockerfile build"></a>2-2. Dockerfile build</h3><p>작성한 Dockerfile을 이용해 Image생성을 해보겠습니다.<br>Dockerfile이 있는 경로에서 아래 명령어로 <code>broker-api2</code> 이라는 image를 생성합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t broker-api2 .</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/40.png" alt="image40"></p><p>‘broker-api2’라는 Image 가 생성된 것을 확인 할 수 있습니다.<br><img src="/img/2020/02/25/41.png" alt="image41"></p><h3 id="2-3-생성된-image로-container-구동하기"><a href="#2-3-생성된-image로-container-구동하기" class="headerlink" title="2-3. 생성된 image로 container 구동하기."></a>2-3. 생성된 image로 container 구동하기.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -itd \</span><br><span class="line">-p 18080:18080 \</span><br><span class="line">-v /home/thinkub0219/webapp:/home/webapp \</span><br><span class="line">--name <span class="string">"broker-api2"</span> broker-api2</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/42.png" alt="image42"></p><h3 id="2-4-application-구동확인"><a href="#2-4-application-구동확인" class="headerlink" title="2-4. application 구동확인"></a>2-4. application 구동확인</h3><p>정상적으로 접근되는 것을 확인 할 수 있습니다.</p><p><img src="/img/2020/02/25/43.png" alt="image43"></p><h1 id="Dockerfile을-사용해야-하는-이유"><a href="#Dockerfile을-사용해야-하는-이유" class="headerlink" title="Dockerfile을 사용해야 하는 이유"></a>Dockerfile을 사용해야 하는 이유</h1><p>2가지 방법을 봤을때 Dockerfile을 사용하는게 좀더 simple(?) 해 보이는건 제 착각 일까요?<br>첫번째 방법으로 Image를 생성한 경우 Image가 삭제 되었을때 Image를 재생성 하는 과정이 Dockerfile에 비해<br>다소 복잡하고 step에 대한 누락이 발생 할 가능성이 있습니다.<br>거기에 반해 Dockerfile을 Git으로 관리하게 되면 Dockerfile 의 변경 History관리가 가능하고 버전 관리가 가능하고<br>Image 재생성 과정이 단순해 집니다.</p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 4. Docker Example</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%204.%20Docker%20Example/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%204.%20Docker%20Example/</id>
    <published>2020-02-25T06:19:53.837Z</published>
    <updated>2020-02-25T07:18:17.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p><strong>Ubuntu OS위에 Docker를 이용해 CentOS Container 생성</strong></p><h3 id="1-docker-hub에서-centOS-Image를-검색해봅니다"><a href="#1-docker-hub에서-centOS-Image를-검색해봅니다" class="headerlink" title="1. docker hub에서 centOS Image를 검색해봅니다."></a>1. docker hub에서 centOS Image를 검색해봅니다.</h3><p><img src="/img/2020/02/25/26.png" alt="image26"></p><ul><li>centOS Image 다운로드 해서 사용하는 방법이 잘 설명되어있습니다. <a href="https://hub.docker.com/_/centos" target="_blank" rel="noopener">Site</a></li></ul><p><img src="/img/2020/02/25/27.png" alt="image27"></p><h3 id="2-centOS-Image-를-다운받습니다"><a href="#2-centOS-Image-를-다운받습니다" class="headerlink" title="2. centOS Image 를 다운받습니다."></a>2. centOS Image 를 다운받습니다.</h3><ul><li>centOS Docker Images 가 다운로드 된 것을 확인 할 수 있습니다.</li><li>images 목록을 확인하는 명령어는 다음과 같습니다.</li></ul><p><img src="/img/2020/02/25/28.png" alt="image28"></p><h3 id="3-centOS-Image를-이용해-Docker-Container-를-생성-실행-시킵니다"><a href="#3-centOS-Image를-이용해-Docker-Container-를-생성-실행-시킵니다" class="headerlink" title="3. centOS Image를 이용해 Docker Container 를 생성(실행) 시킵니다."></a>3. centOS Image를 이용해 Docker Container 를 생성(실행) 시킵니다.</h3><ul><li>Container 를 조회하는 명령어는 다음과 같습니다.</li></ul><p><img src="/img/2020/02/25/29.png" alt="image29"></p><h3 id="4-Ubuntu-OS에-Docker를-이용해서-CentOS-Container가-잘-설치-되어있는지-확인해보겠습니다"><a href="#4-Ubuntu-OS에-Docker를-이용해서-CentOS-Container가-잘-설치-되어있는지-확인해보겠습니다" class="headerlink" title="4. Ubuntu OS에 Docker를 이용해서 CentOS Container가 잘 설치 되어있는지 확인해보겠습니다."></a>4. Ubuntu OS에 Docker를 이용해서 CentOS Container가 잘 설치 되어있는지 확인해보겠습니다.</h3><ul><li>Container 에 접속하는 명령어는 다음과 같습니다.</li></ul><p><img src="/img/2020/02/25/30.png" alt="image30"></p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 3. Docker Command</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%203.%20Docker%20Command/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%203.%20Docker%20Command/</id>
    <published>2020-02-25T05:14:13.481Z</published>
    <updated>2020-02-25T07:18:16.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="Docker-Command"><a href="#Docker-Command" class="headerlink" title="Docker Command"></a>Docker Command</h1><p>Docker 명령어를 확인해 보겠습니다.<br>기본적으로 Docker의 명령어는 <a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">사이트</a> 에 상세히 나와있습니다.</p><p>Docker에서 제공되는 옵션과 명령 종류를 확인해 보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">thinkub0219@instance-1:~$ sudo docker</span><br><span class="line"></span><br><span class="line">Usage:  docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default &quot;/home/thinkub0219/.docker&quot;)</span><br><span class="line">  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with</span><br><span class="line">                           &quot;docker context use&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default &quot;/home/thinkub0219/.docker/ca.pem&quot;)</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default &quot;/home/thinkub0219/.docker/cert.pem&quot;)</span><br><span class="line">      --tlskey string      Path to TLS key file (default &quot;/home/thinkub0219/.docker/key.pem&quot;)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  engine      Manage the docker engine</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container&apos;s changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&apos;s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container&apos;s filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  images      List images</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  info        Display system-wide information</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  login       Log in to a Docker registry</span><br><span class="line">  logout      Log out from a Docker registry</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  ps          List containers</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  search      Search the Docker Hub for images</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Run &apos;docker COMMAND --help&apos; for more information on a command.</span><br></pre></td></tr></table></figure><h3 id="Images-검색하기-Docker-Hub"><a href="#Images-검색하기-Docker-Hub" class="headerlink" title="Images 검색하기 (Docker Hub)"></a>Images 검색하기 (Docker Hub)</h3><p>Docker는 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Dockker Hub</a>라는 public repository가 구축되어있습니다.<br>유명 Linux배포판과 Open Source Project의 Image는 모두 Docker Hub에 공개되어있습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker search ubuntu</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/15.png" alt="image15"></p><h3 id="Images-목록-확인하기"><a href="#Images-목록-확인하기" class="headerlink" title="Images 목록 확인하기"></a>Images 목록 확인하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/16.png" alt="image16"></p><h3 id="Image-다운로드하기"><a href="#Image-다운로드하기" class="headerlink" title="Image 다운로드하기"></a>Image 다운로드하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull [OPTION] name[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/17.png" alt="image17"></p><h3 id="Images-삭제하기"><a href="#Images-삭제하기" class="headerlink" title="Images 삭제하기"></a>Images 삭제하기</h3><ul><li>Images로 Container가 실행되어있으면 Image는 삭제 되지 않습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi [OPTION] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/18.png" alt="image18"></li></ul><h3 id="Image-History-보기"><a href="#Image-History-보기" class="headerlink" title="Image History 보기"></a>Image History 보기</h3><ul><li>Image생성 History 를 볼수 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">history</span> IMAGE</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/19.png" alt="image19"></li></ul><h3 id="Container-실행-생성"><a href="#Container-실행-생성" class="headerlink" title="Container 실행(생성)"></a>Container 실행(생성)</h3><p>Container 를 실행하는 명령은 다음과 같습니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run [OPTION] IMAGE[:TAB|@DIGEST] [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>자주 사용하는 옵션들</p><table><thead><tr><th>Options</th><th>Description</th></tr></thead><tbody><tr><td>-d</td><td>detached mode(background 모드)</td></tr><tr><td>-p</td><td>Host와 Container Port를 연결(port forwarding)</td></tr><tr><td>-v</td><td>Host와 Container의 Directory를 연결(mount)</td></tr><tr><td>-e</td><td>Container 내에서 사용할 환경변수 설정</td></tr><tr><td>-name</td><td>Container 이름설정</td></tr><tr><td>-rm</td><td>Container(Process) 종료시 Container 자동제거</td></tr><tr><td>-it</td><td>-i와 -t를 동시에 사용한것으로 terminal(키보드) 입력을 위한 옵션</td></tr><tr><td>-link</td><td>Conteinaer 연결</td></tr></tbody></table><h3 id="Container-목록-확인하기"><a href="#Container-목록-확인하기" class="headerlink" title="Container 목록 확인하기"></a>Container 목록 확인하기</h3><ul><li>현재 설치된 Container의 목록을 보여주는 명령어입니다.</li><li>일반적으로 <code>-a</code> 옵션을 붙여서 많이 사용합니다 (-a 옵션을 주지 않으면 종료된 Container는 보이지 않습니다.)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/20.png" alt="image20"></li></ul><h3 id="Container-Stop-Start-Restart"><a href="#Container-Stop-Start-Restart" class="headerlink" title="Container Stop / Start / Restart"></a>Container Stop / Start / Restart</h3><ul><li>실행 중인 컨테이너를 중지하거나 시작 또는 재시작할 수 있는 명령어입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">sudo docker start CONTAINER</span><br><span class="line">sudo docker restart CONTAINER</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/21.png" alt="image21"></li></ul><h3 id="Container-제거"><a href="#Container-제거" class="headerlink" title="Container 제거"></a>Container 제거</h3><ul><li>Container를 제거하기 위해선 Stop 상태여야 합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/22.png" alt="image22"></li></ul><h3 id="Container-Log-보기"><a href="#Container-Log-보기" class="headerlink" title="Container Log 보기"></a>Container Log 보기</h3><ul><li>Container가 정상적으로 실행이 되었는지 확인이 필요한 경우가 있습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs CONTAINER</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/23.png" alt="image23"></li><li>option을 주지 않는경우 전체 log를 출력합니다.</li><li>마지막 n줄의 log를 보는방법은 다음과 같습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs --tail 10 CONTAINER</span><br></pre></td></tr></table></figure></li><li>실시간 로그를 확인하는 방법은 다음과 같습니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs -f CONTAINER</span><br></pre></td></tr></table></figure></li></ul><h3 id="Container에-들어가기"><a href="#Container에-들어가기" class="headerlink" title="Container에 들어가기"></a>Container에 들어가기</h3><ul><li>Container를 관리하다 보면 실행중인 Container에 들어가야 하는경우가 많습니다.</li><li>Conatiner에 SSH를 설치해도 되지만 추천하지 않는다고 합니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker attach CONATINER</span><br></pre></td></tr></table></figure></li></ul><h3 id="Container-안의-명령-실행하기"><a href="#Container-안의-명령-실행하기" class="headerlink" title="Container 안의 명령 실행하기"></a>Container 안의 명령 실행하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p><img src="/img/2020/02/25/24.png" alt="image24"></p><h3 id="Container-안의-파일-꺼내기-복사하기"><a href="#Container-안의-파일-꺼내기-복사하기" class="headerlink" title="Container 안의 파일 꺼내기(복사하기)"></a>Container 안의 파일 꺼내기(복사하기)</h3><ul><li>Container의 내부파일을 Host에 복사하는 기능입니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp CONTAINER_NAME:PATH HOST_PATH</span><br></pre></td></tr></table></figure><img src="/img/2020/02/25/25.png" alt="image25"></li></ul><p>이 외에도 많은 기능들에 대해서는 <a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">사이트</a>에서 확인해보면서 사용해 보면 될 것 같습니다. </p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 2. Docker Install</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%202.%20Docker%20Install/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%202.%20Docker%20Install/</id>
    <published>2020-02-25T05:06:27.492Z</published>
    <updated>2020-02-25T07:18:15.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="Docker-Install"><a href="#Docker-Install" class="headerlink" title="Docker Install"></a>Docker Install</h1><p>Docker의 설치 방법은 docker docs에 보면 os별로 상세히 나와 있습니다. <a href="https://docs.docker.com/install/" target="_blank" rel="noopener">Install</a></p><h3 id="제품종류"><a href="#제품종류" class="headerlink" title="제품종류"></a>제품종류</h3><table><thead><tr><th>Community Edition <code>(CE)</code></th><th>Enterprise Edition <code>(EE)</code></th></tr></thead><tbody><tr><td>Docker를 시작하고 컨테이너 기반 앱을 실험하려는<br> 개발자 및 소규모 팀에 이상적(무료)</td><td>업무용 응용프로그램 제작, 배송 및 실행하는<br> 엔터프라이즈 개발 및 IT팀을 위한 설계(유료)</td></tr></tbody></table><h3 id="Update-Cycle"><a href="#Update-Cycle" class="headerlink" title="Update Cycle"></a>Update Cycle</h3><p><img src="/img/2020/02/25/20200225_10.png" alt="image10"></p><p><strong>Docker CE 버전을 설치</strong></p><h3 id="Docker-Install-1"><a href="#Docker-Install-1" class="headerlink" title="Docker Install"></a>Docker Install</h3><ul><li><p>Ubuntu 18.04.3 LTS 에서 설치 진행</p></li><li><p>Docker 는 linux kernel을 사용해야 하기 때문에 root권한으로 진행되어야 합니다.</p></li><li><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">docker 설치 메뉴얼</a></p></li><li><p>처음 서버를 받으면 당연히 docker가 설치되어있지 않습니다.<br><img src="/img/2020/02/25/20200225_11.png" alt="image11"></p></li></ul><h3 id="1-package-update를-진행합니다"><a href="#1-package-update를-진행합니다" class="headerlink" title="1. package update를 진행합니다."></a>1. package update를 진행합니다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h3 id="2-필요한-package를-설치합니다"><a href="#2-필요한-package를-설치합니다" class="headerlink" title="2. 필요한 package를 설치합니다."></a>2. 필요한 package를 설치합니다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><h3 id="3-docker-의-공식-GPG-키를-추가합니다"><a href="#3-docker-의-공식-GPG-키를-추가합니다" class="headerlink" title="3. docker 의 공식 GPG 키를 추가합니다."></a>3. docker 의 공식 GPG 키를 추가합니다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>GPG 키가 추가되었는지 확인한다 (<code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>)<br><img src="/img/2020/02/25/20200225_12.png" alt="image12"></p><h3 id="4-안정적인-저장소-설정을-합니다"><a href="#4-안정적인-저장소-설정을-합니다" class="headerlink" title="4. 안정적인 저장소 설정을 합니다."></a>4. 안정적인 저장소 설정을 합니다.</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><h3 id="5-Docker-CE-설치하기"><a href="#5-Docker-CE-설치하기" class="headerlink" title="5. Docker CE 설치하기"></a>5. Docker CE 설치하기</h3><ul><li><strong>버전을 지정하지 않고 설치 또는 업데이트를 하면 항상 최신버전이 설치되므로 안정성 측면에서 적합하지 않을 수도 있습니다.</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-설치확인"><a href="#6-설치확인" class="headerlink" title="6. 설치확인"></a>6. 설치확인</h3><p><img src="/img/2020/02/25/20200225_13.png" alt="image13"></p><h1 id="nvidia-docker-Install"><a href="#nvidia-docker-Install" class="headerlink" title="nvidia-docker Install"></a>nvidia-docker Install</h1><p>위 단계로 일반적인 Docker설치가 완료되었습니다. 하지만 NVIDIA의 GPU를 이용하시면서 여려 환경의 CUDA Toolkit을 이용할 경우<br>nvidia-docker라는 확장기능을 추가하면 보다 편리하게 사용할 수 있습니다.</p><p>nvidia-docker를 설치하고자 하실 경우 호스트 운영체제에 먼저 NVIDIA 드라이버가 설치되어 있어야 합니다.<br>NVIDIA의 그래픽카드 또는 GPU를 사용하지 않는 경우 이 과정을 진행하고 Docker 설치과정을 끝내실 수 있습니다.</p><p><img src="/img/2020/02/25/20200225_14.png" alt="image14"></p><h3 id="1-저장소-추가"><a href="#1-저장소-추가" class="headerlink" title="1. 저장소 추가"></a>1. 저장소 추가</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \</span><br><span class="line">  sudo apt-key add -</span><br><span class="line"></span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | \</span><br><span class="line">sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="2-nvidia-docker설치"><a href="#2-nvidia-docker설치" class="headerlink" title="2. nvidia-docker설치"></a>2. nvidia-docker설치</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>NVIDIA의 CUDA Docker 컨테이너 이미지 버전들은 아래의 페이지에 방문하시면 확인 하실 수 있습니다.<br><a href="https://hub.docker.com/r/nvidia/cuda/tags/" target="_blank" rel="noopener">https://hub.docker.com/r/nvidia/cuda/tags/</a></p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; title=&quot;Index&quot;&gt;&lt;/a&gt;Index&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Docker &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://thinkub.github
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker - 1. Docker의 개념</title>
    <link href="http://yoursite.com/2020/02/25/Docker%20-%201.%20Docker%EC%9D%98%20%EA%B0%9C%EB%85%90/"/>
    <id>http://yoursite.com/2020/02/25/Docker%20-%201.%20Docker%EC%9D%98%20%EA%B0%9C%EB%85%90/</id>
    <published>2020-02-25T04:30:04.962Z</published>
    <updated>2020-02-25T07:18:14.135Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 관련 블로그를 작성하는 중에 회사에서 공유 문서를 작성하라는 지침을 받고<br>회사 GitLab Wiki에 작성한것을 옮겨 본다.</p><h1 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h1><hr><ol><li>Docker <ol><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%201.%20Docker의%20개념/" target="_blank" rel="noopener">Docker 개념</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%202.%20Docker%20Install/" target="_blank" rel="noopener">Docker Install</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%203.%20Docker%20Command/" target="_blank" rel="noopener">Docker Command</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%204.%20Docker%20Example/" target="_blank" rel="noopener">Docker Example</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%205.%20Image%20만들기/" target="_blank" rel="noopener">Image 만들기</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%206.%20Dockerfile/" target="_blank" rel="noopener">Dockerfile</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%207.%20Docker%20Compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://thinkub.github.io/2020/02/25/Docker%20-%208.%20Image%20저장소/" target="_blank" rel="noopener">Image 저장소</a></li></ol></li></ol><hr><ol start="2"><li>Container Orchestration <ol><li>Container Orchestration 이란</li><li>kubernetes(k8s)</li><li>kubernetes install</li><li>kubernetes ui</li><li>kubernetes를 이용해 배포해보기</li><li>kubectl CLI</li></ol></li></ol><hr><ol start="3"><li>Provisioning <ol><li>Provisioning이란</li><li>Ansible</li><li>Ansible을 이용해 kubernetes cluster 생성하기</li></ol></li></ol><h1 id="What-Is-Docker"><a href="#What-Is-Docker" class="headerlink" title="What Is Docker?"></a>What Is Docker?</h1><p>Docker는 2013년 3월 Docker에서 출시한 오픈소스 컨테이너 프로젝트입니다.</p><p>Docker is an open-source engine that automates the deployment of any application as a lightweight, portable, self-sufficient container that will run virtually anywhere.</p><blockquote><p>Docker는 거의 어디에서나 실행되는 경량이면서 portable하고, 자급자족인 컨테이너 응용 프로그램의 배포를 자동화하는 오픈소스 엔진입니다.</p></blockquote><p><strong>직역을 해도 docker 어떤건지에 대해 이해하기는 쉽지 않습니다.</strong><br><img src="/img/2020/02/25/20200225_01.png" alt="image01"></p><p>Docker는 어느 플랫폼에서나 재현가능한 어플리케이션 컨테이너를 만들어주는 것을 목표합니다.<br>LXC(리눅스 컨테이너)라는 개념에서 출발해서 특정 리눅스 배포판에서 사용 가능합니다.<br>하지만 거의 대부분이 사용하는 Linux OS 입니다. Cent, Ubuntu, Debian, Fedora 등입니다.<br>가상 머신이라고 하기보다는 격리된 환경을 만들어주는 도구입니다.</p><h3 id="Docker의-특징"><a href="#Docker의-특징" class="headerlink" title="Docker의 특징"></a>Docker의 특징</h3><ul><li>유연성(Flexible): 복잡한 Application도 Container화 할 수 있습니다.</li><li>경량(Lightweight): Container는 Host Kernel을 사용하고 공유합니다.</li><li>교환가능(Interchangeable): 업데이트 및 업그레이드를 즉시 배포 할 수 있습니다.</li><li>휴대성(Portable): 로컬로 구축하고, 클라우드에 배치하고, 어디서나 실행 가능합니다.</li><li>확장성(Scalable): Container 복제본을 늘리고 자동으로 배포 할 수 있습니다.</li><li>스태킹(Stackable): 서비스를 세로 및 가로로 쌓을 수 있습니다.</li></ul><h1 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker?"></a>Why Docker?</h1><p>그렇다면 docker를 사용해야 할 이유가 뭘까요?</p><p>서버가 물리서버에서 클라우드 서버 환경으로 바뀌면서 클릭 몇 번 만으로 서버를 만들어 낼 수 있게 되었습니다.<br>서버의 수가 증가하면서 관리하기 어려운 환경이 되면서 <strong>Immutable Infrastructure</strong>라는 패러다임이 나왔습니다.</p><h3 id="Immutable-Infrastructure"><a href="#Immutable-Infrastructure" class="headerlink" title="Immutable Infrastructure"></a>Immutable Infrastructure</h3><p>호스트 OS와 서비스 운영환경을 분리하고, <strong>한 번 설정한 운영환경은  변하지 않는다</strong></p><ul><li><strong>편리한 관리</strong>: 서비스 운영 환경을 이미지로 생성했기 때문에 이미지 자체만 관리하면 됩니다. 특히 이미지를 중앙 관리하여 체계적인 배포와 관리를 할 수 있습니다. 또한, 이미지 생성 설정도 파일로 되어 있기 때문에 버전 관리 시스템을 활용할 수 있습니다.</li><li><strong>확장</strong> : 이미지 하나로 서버를 계속 찍어낼 수 있습니다. 따라서 클라우드 플랫폼의 자동 확장(Auto Scaling) 기능과 연동하면 손쉽게 서비스를 확장할 수 있습니다.</li><li><strong>테스트</strong>: 개발자의 PC나 테스트 서버에서 이미지를 실행하기만 하면 서비스 운영 환경과 동일한 환경이 구성되기 때문에 테스트가 매우 쉽습니다.</li><li><strong>가볍다</strong> : 운영체제와 서비스 운영 환경을 분리하여 가볍고(Lightweight) 어디서든 실행 가능한(Portable) 환경을 제공합니다.</li></ul><p><strong>Immutable Infrastructure를 구현한 프로젝트가 바로 <code>Docker</code> 입니다.</strong></p><p><img src="/img/2020/02/25/20200225_02.png" alt="image02"></p><ul><li>빠른 마켓 출시</li><li>개발자의 생산성</li><li>배포속도</li><li>IT 인프라 축소</li><li>IT 운영 효율성</li><li>빠른 문제해결</li></ul><p><strong>Docker는 Image를 이용해 Container를 생성(실행)합니다.</strong><br><strong>그러기 위해선 Docker Imager, Docker Container가 무엇인지 알아야 합니다.</strong><br><strong>Image와 Container에 대한 개념을 먼저 알아보겠습니다.</strong></p><h1 id="Docker-Images"><a href="#Docker-Images" class="headerlink" title="Docker Images"></a>Docker Images</h1><p>이미지는 추상적인 개념이며, 이미지를 기반으로 생성된 컨테이너가 실행됩니다.<br>이미지는 코드, 런타임, 도서관, 환경 변수 및 구성 파일 등 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 실행 가능한 패키지로 상태값을 가지지 않고 변하지 않습니다.<strong>(Immutable)</strong><br>이미지는 직접 제작할 수도 있고 Docker Hub 와 같은 repository 에 올라가 있는 image 를 사용목적에 맞게 다운받아서 사용할 수 있습니다.</p><p><img src="/img/2020/02/25/20200225_03.png" alt="image03"></p><p>도커 이미지는 Docker hub에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있습니다. 현재 공개된 도커 이미지는 50만개가 넘고 Docker hub의 이미지 다운로드 수는 80억회에 이릅니다. 누구나 쉽게 이미지를 만들고 배포할 수 있습니다.</p><p><img src="/img/2020/02/25/20200225_04.png" alt="image04"></p><p>참고로 Docker Hub는 유료입니다. 물론 무료로 사용할 수 있지만 1개의 private repository 를 제공해 줍니다. <strong>(개인사용자기준)</strong> 기업이 사용하기 위해서는 유료정책 만 있습니다.</p><p><img src="/img/2020/02/25/20200225_05.png" alt="image05"></p><p>이미지는 Container를 실행하기 위한 모든 정보를 가지고 있기 때문에 용량이 큰 편입니다. 최초 Image를 다운받은 후 기존 Image에 파일이 하나 추가됬다고 Image를 다시 다운받는다면 매우 비효율 적이죠</p><p>Docker는 이런 문제를 Layer라는 개념을 사용해서 해결했습니다.<br>Image는 n개의 Layer로 구성되고 파일이 추가되거나 수정되면 새로운 Layer가 생성됩니다.<br>예를들어 ubuntu 가 a, b, c layer 로 이루어져 있다면 ubuntu image 베이스로 만든 nginx Image는 A, B, C 그리고 nginx가 됩니다.<br>여기에 webapp image를 nginx 기반으로 만들어 졌다면 a, b, c, nginex, source 레이어가 합쳐진 image가 됩니다.<br>이런 구성에서 webapp source를 수정한다면 source layer 만 다운받아져서 사용이 가능합니다.</p><p>이런식으로 Docker는 Image를 통째로 생성하지 않고, 바뀐 부분만 생성한 뒤 부모 이미지를 계속 참조하는 방식으로 동작합니다.</p><p><img src="/img/2020/02/25/20200225_06.png" alt="image06"></p><h1 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h1><p><img src="/img/2020/02/25/20200225_07.png" alt="image07"></p><p><strong>Docker Container 는 Docker Image를 기반으로 실행된 상태</strong> 입니다.<br>1개의 Image로 n개의 Container를 구성 할 수 있습니다.<br>운영체제로 예를 들면 Image는 실행파일이고 Container는 실행파일로 작동하는 프로세스입니다.</p><p>Container는 Image로부터 생성되지만 Container내부의 내용은 변경 가능합니다. <strong>(Mutable)</strong><br>Conatiner가 변경된다고 해서 Image에는 어떠한 영향도 작용되지 않습니다.</p><p>Docker Container는 Linux Container에서 기반된 기술입니다.<br>초기 버전에서는 Linux Container를 사용했지만 이후로 자체 개발한 Container를 개발했습니다.</p><p>Container는 가상화방식중 하나로 <strong>프로세스를 격리</strong> 해줍니다.</p><p><a href="https://youtu.be/n-JwAM6XF88" target="_blank" rel="noopener"><img src="/img/2020/02/25/20200225_08.png" alt="Video Label"></a><br>출처 : RedHat Videos</p><h3 id="Docker-Container는-가상머신인가"><a href="#Docker-Container는-가상머신인가" class="headerlink" title="Docker Container는 가상머신인가?"></a>Docker Container는 가상머신인가?</h3><p><img src="/img/2020/02/25/20200225_09.png" alt="image09"></p><p>왼쪽이 docker Container이고 오른쪽이 VM 입니다.<br>Docker를 처음 접하는 분들은 Docker를 가상머신으로 인식하시는 분들이 많습니다.<br>Docker Container 를 볼때 외부에서 볼떄는 process 로 보이고 내부에서 보면 vm 같이 보입니다.<br>Docker는 가상화의 한 방법이긴 하지만 기존 가상화 / 반가상화 방식과는 다르게 Guest OS 설치가 필요없습니다.<br>vm의 경우에 하드웨어 리소스를 사용하기 위해 하이퍼바이저 설치가 필요하고 각자 Guest OS 설치를 해야 합니다.<br>거기에 반해 Docker Container 는 Linux 커널위에서 단순히 프로세스를 격리 시키기 때문에 가볍고 빠르게 동작합니다.</p><p>이러니 저러니 해도 직접 설치해서 사용해보는것 만큼 좋은 공부는 없는것 같습니다.<br>일단 Docker를 설치해보도록 하겠습니다.</p><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a><br><a href="http://pyrasis.com/book/DockerForTheReallyImpatient" target="_blank" rel="noopener">http://pyrasis.com/book/DockerForTheReallyImpatient</a><br><a href="https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose" target="_blank" rel="noopener">https://www.44bits.io/ko/post/almost-perfect-development-environment-with-docker-and-docker-compose</a><br><a href="https://tech.osci.kr/docker/2018/09/10/45749387/" target="_blank" rel="noopener">https://tech.osci.kr/docker/2018/09/10/45749387/</a><br><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 관련 블로그를 작성하는 중에 회사에서 공유 문서를 작성하라는 지침을 받고&lt;br&gt;회사 GitLab Wiki에 작성한것을 옮겨 본다.&lt;/p&gt;
&lt;h1 id=&quot;Index&quot;&gt;&lt;a href=&quot;#Index&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker(2)</title>
    <link href="http://yoursite.com/2020/01/03/Docker(2)/"/>
    <id>http://yoursite.com/2020/01/03/Docker(2)/</id>
    <published>2020-01-03T00:04:46.123Z</published>
    <updated>2020-02-25T04:57:33.232Z</updated>
    
    <content type="html"><![CDATA[<p>지난 포스팅엔 Docker가 어떤건지 확인해봤다. 이번엔 Docker를 설치 해보고 Docker image를 이용해 container를 만들고 명령어를 알아보도록 하자.</p><h1 id="Docker-설치하기"><a href="#Docker-설치하기" class="headerlink" title="Docker 설치하기"></a>Docker 설치하기</h1><p>docker는 기본적으로 root권한이 필요하다. 이전 회사에서는 root권한을 일개 개발자에게 주지 않아서 관리자에게 설치 요청을 한 적도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -fsSL https://get.docker.com/ | sudo sh</span><br></pre></td></tr></table></figure><p>주의할 점으로 Docker를 실행하기 위한 kernel 버전은 3.10.x 버전 이상이어야 한다.<br>ubuntu나 centos가 아닌 경우는 <a href="https://docs.docker.com/install" target="_blank" rel="noopener">이곳</a> 을 확인하자.</p><p>설치 확인<br><img src="/img/2020/01/03/20200103_01.JPG" alt="image01"></p><p>내용을 보면 버전정보가 Client와 Server로 구분되어있다. Docker는 하나의 실행파일이지만 실제로 Client와 Server를 각각 수행 할 수 있다. Docker Command를 입력하면 Docker Client가 Docker Server로 Command를 전송하고 결과를 받아 터미널에 출력해준다.<br><img src="/img/2020/01/03/20200103_02.png" alt="image02"></p><h1 id="Container-실행하기"><a href="#Container-실행하기" class="headerlink" title="Container 실행하기"></a>Container 실행하기</h1><p>Docker를 실행하는 명령어는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run [OPTIONS] IMAGE:[:TAG|@DIGEST] [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>자주 사용하는 옵션들.</p><table><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td>-d</td><td>detached mode (BackGround Mode)</td></tr><tr><td>-p</td><td>Host와 Container Port를 연결</td></tr><tr><td>-v</td><td>Host와 Container 디렉토리를 연결</td></tr><tr><td>-e</td><td>Container에서 사용할 환경변수 설정</td></tr><tr><td>-name</td><td>Container 이름설정</td></tr><tr><td>-rm</td><td>프로세스 종료시 Container 자동 제거</td></tr><tr><td>-it</td><td>-i와 -t를 동시에 사용한 것으로 Terminal 입력을 위한 옵션</td></tr><tr><td>-link</td><td>Container연결</td></tr></tbody></table><h3 id="Centos7-설치해보기"><a href="#Centos7-설치해보기" class="headerlink" title="Centos7 설치해보기"></a>Centos7 설치해보기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run centos:7</span><br></pre></td></tr></table></figure><p><img src="/img/2020/01/03/20200103_03.PNG" alt="image03"><br><code>run</code> 명령어를 사용하면 사용할 Image가 저장되어있는지 확인하고 없다면 다운로드 한 후 컨테이너를 생성 하고 시작한다.</p><p>그럼 해당 container에 centos가 정상적으로 설치되었는지 확인해보자<br><img src="/img/2020/01/03/20200103_04.PNG" alt="image04"></p><h1 id="Docker-CommandLine"><a href="#Docker-CommandLine" class="headerlink" title="Docker CommandLine"></a>Docker CommandLine</h1><p>docker command의 자세한 정보는 <a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">여기</a> 에서 확인이 가능하다. 많이 사용되는 CommandLine 위주로 살펴 보자</p><h3 id="Container-목록-확인하기-ps"><a href="#Container-목록-확인하기-ps" class="headerlink" title="Container 목록 확인하기 (ps)"></a>Container 목록 확인하기 (ps)</h3><p>현재 설치된 Container의 목록을 보여주는 명령어이다.<br>일반적으로 <code>-a</code> 옵션을 붙여서 많이 사용한다 (-a 옵션을 주지 않으면 종료된 Container는 보이지 않는다) </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure><p><img src="/img/2020/01/03/20200103_06.PNG" alt="image06"></p><h3 id="Container-Stop-Start"><a href="#Container-Stop-Start" class="headerlink" title="Container Stop / Start"></a>Container Stop / Start</h3><p>실행 중인 컨테이너를 중지하거나 시작 할 수 있는 명령어이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">sudo docker start CONTAINER</span><br></pre></td></tr></table></figure><p><img src="/img/2020/01/03/20200103_07.PNG" alt="image07"><br>첨부된 이미지의 mysql:5.7 Container 를 Stop / Start 해봤다. Container 의 STATUS 상태를 보면 된다.</p><h3 id="Container-제거-rm"><a href="#Container-제거-rm" class="headerlink" title="Container 제거(rm)"></a>Container 제거(rm)</h3><p>Container를 제거하기 위해선 Stop 상태여야 한다. Container 제거하는 명령어는 아래와 같다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p><img src="/img/2020/01/03/20200103_08.PNG" alt="image08"><br>첨부된 이미지에서 mysql:5.7 Container 를 삭제해봤다<br>Container 가 종료상태가 아닌 경우 제거를 시도하면 running 중이지 제거가 불가능하다는 Error가 발생한다.<br>Container 종료 후 삭제하면 정상적으로 Container 가 삭제되는 것을 확인 할 수 있다.</p><h3 id="Image-목록-확인하기-images"><a href="#Image-목록-확인하기-images" class="headerlink" title="Image 목록 확인하기 (images)"></a>Image 목록 확인하기 (images)</h3><p>다운로드된 이미지를 확인하는 명령어이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><p><img src="/img/2020/01/03/20200103_05.PNG" alt="image05"><br>제가 설치한 서버에는 centos, mongo, mysql images가 있네요</p><h3 id="Image-다운로드하기"><a href="#Image-다운로드하기" class="headerlink" title="Image 다운로드하기"></a>Image 다운로드하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull [OPTION] name[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure><p>ubuntu 를 다운로드 해보겠습니다.<br><img src="/img/2020/01/03/20200103_09.PNG" alt="image09"></p><h3 id="Images-삭제하기"><a href="#Images-삭제하기" class="headerlink" title="Images 삭제하기"></a>Images 삭제하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi [OPTION] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p>Image 삭제시 주의 할 점은 Image를 통해 Container를 생성 한 경우는 Image를 삭제 할 수 없다.<br>Container를 먼저 삭제 한 이후 삭제가 가능하다<br><img src="/img/2020/01/03/20200103_10.PNG" alt="image10"><br>첨부파일과 같이 현재 Container가 생성된 mongo의 image를 삭제하려고하면 Error가 발생한다</p><h3 id="Container-log보기"><a href="#Container-log보기" class="headerlink" title="Container log보기"></a>Container log보기</h3><p>Container 가 정상적으로 실행이 되었는지 확인이 필요한 경우가 있는데<br>log를 보는 방법이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs <span class="variable">$&#123;containerId&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/img/2020/01/03/20200103_11.PNG" alt="image11"></p><p>아무 옵션을 주지 않았을 때는 전체 로그를 출력합니다.<br>마지막 10줄의 로그만 보는 방법은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs --tail 10 <span class="variable">$&#123;containerId&#125;</span></span><br></pre></td></tr></table></figure><p>실시간 로그를 확인하는 방법은 아래와 같다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs -f <span class="variable">$&#123;containerId&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Container-들어가기"><a href="#Container-들어가기" class="headerlink" title="Container 들어가기"></a>Container 들어가기</h3><p>Container를 관리하다 보면 실행중인 Container에 들어가서 로그를 확인한다거나 파일을 실행한다거나 하는 작업이 필요할 경우가 많다.<br>Container 에 SSH를 설치해도 되지만 추천하지 않는다고 한다. 컨테이너 내부에 들어가는 명령은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>ubuntu 서버에 설치된 centos container 에 들어가보도록 하겠다<br><img src="/img/2020/01/03/20200103_12.PNG" alt="image12"></p><p>이 외에 많은 기능들이 있는데 그러한 부분은 reference를 보면서 활용해 보면 될 듯 하다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><blockquote><p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-2.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;지난 포스팅엔 Docker가 어떤건지 확인해봤다. 이번엔 Docker를 설치 해보고 Docker image를 이용해 container를 만들고 명령어를 알아보도록 하자.&lt;/p&gt;
&lt;h1 id=&quot;Docker-설치하기&quot;&gt;&lt;a href=&quot;#Docker-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker(1)</title>
    <link href="http://yoursite.com/2019/12/16/Docker(1)/"/>
    <id>http://yoursite.com/2019/12/16/Docker(1)/</id>
    <published>2019-12-16T05:54:30.695Z</published>
    <updated>2020-01-02T08:37:57.322Z</updated>
    
    <content type="html"><![CDATA[<p>2020년의 첫 프로젝트를 시작하려 한다.<br>회사의 주요 서비스 (및 모듈) 들을 docker 배포 환경으로 만드는 작업이다.</p><p>일단 멘붕.</p><p>docker로 mongo-db 나 gitlab정도만 깔아봤지<br>정확한 개념을 잡고 있진 않았기에 어떻게 해야 할지 걱정이 많았다.<br>먼저 Docker가 무엇인지 알아보자.</p><h1 id="Docker는-VM인가"><a href="#Docker는-VM인가" class="headerlink" title="Docker는 VM인가?"></a>Docker는 VM인가?</h1><p>처음 Docker를 접했을때 “아 이건 VM이구나?!” 라는 생각을 했다.<br>처음 docker를 접한건 2018년 말 mongo-db를 설치하면서 였다.<br>주변에서 docker docker 하길래 그래 이왕 하는김에 docker를 써보자. 하면서 구글링을 열심히 했다. 어찌저찌 깔려서 돌아가는 모습을 보면서. docker == VM 이라는 개념이 잡혀버렸다.<br>하지만 docker 는 VM과 비슷하지만 다르다. docker에 대해 알아보자.</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker?"></a>Docker?</h1><p>개념은 Docker는 Container 기반의 오픈소스 가상화 플랫폼이다.<br>그렇다면 Container 무엇인가? 그리고 Container를 실행하는데 필수인 Image에 대해서 알아보자</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>격리된 공간에서 Process가 동작하는 기술. 가상화 기술의 하나. 하지만 기존 가상화 방식은 주로 OS가상화 였다. VMware, Virtualbox 등 가상머신은 호스트 OS위에 게스트 OS전체를 가상화하여 사용하는 방식이다. 이 경우 무겁고 느려서 운영환경에선 사용할 수 없었다.<br><img src="/img/2019/12/19/20191219_01.png" alt="image01"></p><p>위 Image와 같이 Guest OS가 없이 단순히 프로세스를 격리 시키기 때문에 가볍고 빠르게 동작한다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가하고 사용하고 성능적으로 손실이 적다.</p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><img src="/img/2019/12/19/20191219_02.png" alt="image02"><br>Image는 Container 실행에 필요한 파일과 설정값등을 포함하고 있는것.<br>상태값을 가지지 않고 변하지 않는다. Container는 Image를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장된다. 같은 Image에서 여러개의 Continer를 생성할 수 있고 Conetiner의 상태변화에 Image는 영향이 없다. </p><p>Docker Image는 <a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a> 에서 다운받거나 등록 할 수 있다.<br><a href="docs.docker.com/registry/">Docker Registry</a> 저장소를 직접 만들어 관리할 수 있다.</p><h1 id="Docker의-장점"><a href="#Docker의-장점" class="headerlink" title="Docker의 장점"></a>Docker의 장점</h1><h3 id="Layer-저장방식"><a href="#Layer-저장방식" class="headerlink" title="Layer 저장방식"></a>Layer 저장방식</h3><p><img src="/img/2019/12/19/20191219_03.png" alt="image03"><br>Docker Image는 위에 설명한 것 처럼 Container를 실행하기 위한 모든 정보를 가지고 있기 때문에 용량이 큰 편이다. 최초 Image를 다운 받은 후 기존 Image에 파일이 하나 추가됬다고 Image를 다시 다운받는다면 매우 비효율 적이다.</p><p>Docker는 이런 문제를 Layer라는 개념을 사용하여 해결했다.<br>Image n개의 Layer로 구성되고 파일이 추가되거나 수정되면 새로운 Layer가 생성된다.<br>예를 들어 ubuntu Image가 <code>A</code>+<code>B</code>+<code>C</code> Layer로 이루어져있다면 ubuntu Image를 베이스로 만든 nginx Image는 <code>A</code>+<code>B</code>+<code>C</code>+<code>nginx</code> 가 된다. 여기에 webapp Image를 nginx기반으로 만들었다면 <code>A</code>+<code>B</code>+<code>C</code>+<code>nginx</code>+<code>source</code> 가 된다.<br>webapp source를 수정하면 <code>source</code> layer만 다운받으면 된다.</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Docker는 Image를 만들기 위해 <code>Dockerfile</code>이라는 파일에 자체 DSL언어를 이용하여 이미지 생성과정을 적는다. 기존 어떠한 프로젝트 구성을 하기위해 centOS를 깔고 DB설치를 하고 jdk설치를 하고 apache+tomcat 과 같은 was 설정 등을 <code>Dockerfile</code>로 관리 할 수 있다.<br>Dockerfile은 소시와 함께 버전관리 되고 원한다면 누구나 이미지 생성과정을 보고 수정할 수 있다.</p><p>아래는 최근에 작성한 sample이다. 이런식으로 image를 만들게 되면 해당 image로 container 생성시 app이 실행이 된다.</p><ul><li>centOS 설치</li><li>Openjdk 설치</li><li>source code copy</li><li>java 실행<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER ming</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Packages &amp; open jdk 1.8</span></span><br><span class="line">RUN yum updagte -y;</span><br><span class="line">    yum install -y java-1.8.0-openjdk-devel.x86_64;</span><br><span class="line">    yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment"># make Folder</span></span><br><span class="line">RUN mkdir -p /home/tempFolder</span><br><span class="line"></span><br><span class="line"><span class="comment"># source copy</span></span><br><span class="line">COPY . /usr/src/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># log path volume</span></span><br><span class="line">VOLUME /home/logs /home/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># app start</span></span><br><span class="line">EXPOSE 18080</span><br><span class="line">CMD java -server -Dspring.profiles.active=dev -jar /usr/src/app/app.jar</span><br></pre></td></tr></table></figure></li></ul><h3 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h3><p><img src="/img/2019/12/19/20191219_04.png" alt="image04"><br>Docker Image의 용량응 보통 수백메가로 수기가가 넘는 경우도 흔하다. 이렇게 큰 용량의 이미지를 서버에 저장하고 관리하는 것은 쉽지 않은데 Docker hub를 통해 공개 이미지를 무료료 관리해준다.</p><h3 id="Command와-API"><a href="#Command와-API" class="headerlink" title="Command와 API"></a>Command와 API</h3><p>Docker Client의 Command 명령어는 정말 잘 만들어져있다. 대부분의 명령어는 직관적이고 사용하기 쉬우며 Container의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있다. 또한 http기반의 Rest API도 지원하여 확장성이 굉장히 좋고 훌륭한 3rd party tool이 나오기 좋은 환경이다.</p><h3 id="훌륭한-생태계"><a href="#훌륭한-생태계" class="headerlink" title="훌륭한 생태계"></a>훌륭한 생태계</h3><h3 id="커뮤니티-지원"><a href="#커뮤니티-지원" class="headerlink" title="커뮤니티 지원"></a>커뮤니티 지원</h3><p>다음엔 docker container를 실행해보고 명령어에 대해서 살펴볼 예정이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><blockquote><p><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank" rel="noopener">https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020년의 첫 프로젝트를 시작하려 한다.&lt;br&gt;회사의 주요 서비스 (및 모듈) 들을 docker 배포 환경으로 만드는 작업이다.&lt;/p&gt;
&lt;p&gt;일단 멘붕.&lt;/p&gt;
&lt;p&gt;docker로 mongo-db 나 gitlab정도만 깔아봤지&lt;br&gt;정확한 개념
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Feign Client 사용시 form encoder 설정</title>
    <link href="http://yoursite.com/2019/12/13/Feign%20Client%20%EC%82%AC%EC%9A%A9%EC%8B%9C%20form%20encoder%20%EC%84%A4%EC%A0%95/"/>
    <id>http://yoursite.com/2019/12/13/Feign%20Client%20%EC%82%AC%EC%9A%A9%EC%8B%9C%20form%20encoder%20%EC%84%A4%EC%A0%95/</id>
    <published>2019-12-13T01:15:23.638Z</published>
    <updated>2019-12-13T05:46:40.241Z</updated>
    
    <content type="html"><![CDATA[<p>프로젝트에서 Unity로 만든 application과 back-end를 연결하는 Broker-api를 개발하게 되었다.<br>뭐 간단하게 api interface 맞춰서 전달하면 되겠네 라고 생각하며 작업을 진행했다.<br>api 호출은 당연히 feign client를 사용을 했다.<br>그러던 중 jpeg image file을 전달하는 api를 만들었는데(multipart/form-data)<br>다음과 같은 Exception을 만나게 되었다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feign.codec.EncodeException: Could not write request: no suitable HttpMessageConverter found for request type .... and content type [multipart/form-data]</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h1 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h1><p>HttpMessageConver 설정을 해준다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignFormEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringFormEncoder(<span class="keyword">new</span> SpringEncoder(messageConverters));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><blockquote><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/HttpMessageConverter.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/HttpMessageConverter.html</a><br><a href="https://supawer0728.github.io/2018/03/11/Spring-Cloud-Feign/" target="_blank" rel="noopener">https://supawer0728.github.io/2018/03/11/Spring-Cloud-Feign/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;프로젝트에서 Unity로 만든 application과 back-end를 연결하는 Broker-api를 개발하게 되었다.&lt;br&gt;뭐 간단하게 api interface 맞춰서 전달하면 되겠네 라고 생각하며 작업을 진행했다.&lt;br&gt;api 호출은 당연히 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JUnit5</title>
    <link href="http://yoursite.com/2019/12/11/JUnit5/"/>
    <id>http://yoursite.com/2019/12/11/JUnit5/</id>
    <published>2019-12-11T01:24:02.115Z</published>
    <updated>2019-12-13T05:42:45.577Z</updated>
    
    <content type="html"><![CDATA[<p>2018년 초에 프로젝트를 진행하면서 JUnit5 관련 스터디 한 자료가 있어서<br>블로그로 옮겨본다.</p><h1 id="JUnit5"><a href="#JUnit5" class="headerlink" title="JUnit5"></a>JUnit5</h1><p>JUnit은 Java 단위테스트 작성을 위한 표준 framework<br>기존 우리가 사용하던버전은 JUnit4로 새로나온 JUnit5를 알아 볼께요</p><h2 id="차이점"><a href="#차이점" class="headerlink" title="차이점"></a>차이점</h2><ul><li>JUnit 4가 단일 jar였던 것에 비해, JUnit 5는 크게 JUnit Platform, JUnit Jupiter, JUnit Vintage 모듈로 구성되어 있다.<ul><li>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</li></ul></li><li>테스트 작성자를 위한 API 모듈과 테스트 실행을 위한 API가 분리되어 있다.<ul><li>예를 들어, JUnit Jupiter는 테스트 코드 작성에 필요한 junit-jupiter-api 모듈과 테스트 실행을 위한 junit-jupiter-engine 모듈로 분리되어 있다.</li></ul></li><li>자바 8 또는 그 이상 버전을 요구한다.</li></ul><p><img src="/img/2019/12/11/20191211_01.png" alt="image01"></p><h4 id="JUnit-Platform"><a href="#JUnit-Platform" class="headerlink" title="JUnit Platform"></a>JUnit Platform</h4><p>JUnit 플랫폼은 JVM에서 테스트 프레임 워크를 시작하기위한 기초 역할을합니다.<br>또한 플랫폼에서 실행되는 테스트 프레임 워크를 개발하기위한 TestEngine API를 정의합니다.<br>또한 플랫폼은 명령 행에서 플랫폼을 실행하고 Gradle 및 Maven 용 플러그인을 빌드하는 Console Launcher를 제공하며<br>플랫폼에서 TestEngine을 실행하기위한 JUnit 4 기반 Runner도 제공합니다.</p><h4 id="JUnit-Jupiter"><a href="#JUnit-Jupiter" class="headerlink" title="JUnit Jupiter"></a>JUnit Jupiter</h4><p>JUnit 5에서 테스트 및 확장 작성을위한 새로운 프로그래밍 모델과 확장 모델의 조합입니다.<br>Jupiter 하위 프로젝트는 플랫폼에서 Jupiter 기반 테스트를 실행하기위한 TestEngine을 제공합니다.</p><h4 id="JUnit-Vintage"><a href="#JUnit-Vintage" class="headerlink" title="JUnit Vintage"></a>JUnit Vintage</h4><p>플랫폼에서 JUnit 3 및 JUnit 4 기반 테스트를 실행하기위한 TestEngine을 제공합니다.</p><h1 id="Maven-Dependency"><a href="#Maven-Dependency" class="headerlink" title="Maven Dependency"></a>Maven Dependency</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--JUnit 5 Dependency--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--JUnit 4 IDE Compatibility Dependencies--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-launcher<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.19.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-platform-surefire-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JUnit4-와-달라진점"><a href="#JUnit4-와-달라진점" class="headerlink" title="JUnit4 와 달라진점"></a>JUnit4 와 달라진점</h1><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><ul><li>JUnit4<ul><li>이 코드에서 만약 첫 번째 assertEquals()가 실패하면 그 시점에서 테스트 실패하므로 두 번째 assertEquals()를 실행하지 않는다. 이 두 assertEquals()는 실제로는 하나의 score를 검증하는 것이므로 개념적으로 하나를 검증하는 것이다<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assertEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Game game = <span class="keyword">new</span> Game(<span class="number">123</span>);</span><br><span class="line">    Score score = game.guess(<span class="number">134</span>);</span><br><span class="line">    assertEquals(<span class="number">1</span>, score.getStrikes());</span><br><span class="line">    assertEquals(<span class="number">1</span>, score.getBalls());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>JUnit5<ul><li>assertAll()은 함수형인터페이스인 Executable 목록을 파라미터로 갖는다.(Executable 인터페이스는 파라미터가 없고 리턴 타입이 void인 execute() 메서드를 정의하고 있다.)</li><li>함수형 인터페이스이므로 위 코드와 같이 람다식을 사용해서 여러개의 검증을 목록으로 전덜할 수 있다.</li><li>assertAll()의 특징은 목록으로 받은 모두 Executable을 실행한다는 점이다. 그리고 그 중에서 실패한 검증에 대해서만 리포트를 한다. 예를 들어, 위 코드에서 assertAll()로 전달한 모든 Executable이 검증에 실패했다고 하자. 이를 인텔리J에서 실행해보면 assertAll()에서 실패한 모든 검증 결과가 콘솔에 출력되는 것을 알 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssertAllTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertAllSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Game(<span class="number">123</span>);</span><br><span class="line">        Score score = game.guess(<span class="number">145</span>);</span><br><span class="line">        assertAll(</span><br><span class="line">                () -&gt; assertEquals(<span class="number">2</span>, score.getStrikes()),</span><br><span class="line">                () -&gt; assertEquals(<span class="number">1</span>, score.getBalls())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="assertThrows"><a href="#assertThrows" class="headerlink" title="assertThrows"></a>assertThrows</h4><ul><li><p>JUnit4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>(expected = RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testIsGroupSeats_SeatsAreInvalidByCache</span>() <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">// given</span></span><br><span class="line">    List&lt;Integer&gt; logicalSeatIds = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    mockingForSeatsAreInvalidByCache(logicalSeatIds);</span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    service.isSameGroupSeats(logicalPlanId, logicalSeatIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JUnit5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(ArithmeticException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">divide</span>(100, 0))</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> op1, <span class="keyword">int</span> op2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> op1 / op2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="보조-Annotation-DisplayName-Disabled"><a href="#보조-Annotation-DisplayName-Disabled" class="headerlink" title="보조 Annotation @DisplayName @Disabled"></a>보조 Annotation @DisplayName @Disabled</h4><ul><li>@DisplayName은 테스트 클래스나 메서드의 표시 이름을 지정한다</li><li>@Disabled 는 테스트 실행 대상에서 제외한다.<br><img src="/img/2019/12/11/20191211_02.png" alt="image02"></li></ul><h4 id="Assumption"><a href="#Assumption" class="headerlink" title="Assumption"></a>Assumption</h4><ul><li>특정 상황에 따른 TestCode를 실행</li><li>Assumptions.assumeTrue()는 인자로 전달받은 값이 true이면 이후 테스트를 진행하고, 그렇지 않으면 테스트를 생략한다<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String osName = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">    assumingThat(</span><br><span class="line">            osName.startsWith(<span class="string">"Linux"</span>), <span class="comment">// (1) 가정 boolean 또는 BooleanSupplier</span></span><br><span class="line">            () -&gt; assertEquals(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// (2) 가정을 충족할 때 실행할 코드(Executable 타입)</span></span><br><span class="line">    );</span><br><span class="line">    assertEquals(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h4><ul><li>중첩된 구조로 테스트를 구성할 수 있습니다<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"A stack"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestingAStackDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"is instantiated with new Stack()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isInstantiatedWithNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"when new"</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">createNewStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName</span>(<span class="string">"is empty"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName</span>(<span class="string">"throws EmptyStackException when popped"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">stack</span>.<span class="title">pop</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName</span>(<span class="string">"throws EmptyStackException when peeked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">throwsExceptionWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            assertThrows(EmptyStackException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">stack</span>.<span class="title">peek</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName</span>(<span class="string">"after pushing an element"</span>)</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AfterPushing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            String anElement = <span class="string">"an element"</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pushAnElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName</span>(<span class="string">"it is no longer empty"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">isNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName</span>(<span class="string">"returns the element when popped and is empty"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName</span>(<span class="string">"returns the element when peeked but remains not empty"</span>)</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">returnElementWhenPeeked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><blockquote><p><a href="http://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="noopener">http://junit.org/junit5/docs/current/user-guide/</a><br><a href="http://javacan.tistory.com/entry/JUnit-5-Intro?category=454313" target="_blank" rel="noopener">http://javacan.tistory.com/entry/JUnit-5-Intro?category=454313</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018년 초에 프로젝트를 진행하면서 JUnit5 관련 스터디 한 자료가 있어서&lt;br&gt;블로그로 옮겨본다.&lt;/p&gt;
&lt;h1 id=&quot;JUnit5&quot;&gt;&lt;a href=&quot;#JUnit5&quot; class=&quot;headerlink&quot; title=&quot;JUnit5&quot;&gt;&lt;/a&gt;JU
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://yoursite.com/2019/12/11/Kafka/"/>
    <id>http://yoursite.com/2019/12/11/Kafka/</id>
    <published>2019-12-11T01:08:47.229Z</published>
    <updated>2019-12-13T05:42:48.510Z</updated>
    
    <content type="html"><![CDATA[<p>회사에 <a href="https://aladin.co.kr/shop/wproduct.aspx?ItemId=142100738" target="_blank" rel="noopener">카프카, 데이터 플랫폼의 최강자</a> 책의 저자인 고승범 님이 오셔서<br>Kafka에 대해 발표를 한적이 있는데 그 때 적었던 내용.<br>막 적다 보니까 뭘 쓴건 지도 모르겠다;;;<br>일단 기록 저장용으로 옮겨본다</p><h4 id="Kafka란"><a href="#Kafka란" class="headerlink" title="Kafka란?"></a>Kafka란?</h4><p>Kafka®는 실시간 데이터 파이프 라인 및 스트리밍 앱을 구축하는 데 사용됩니다. 수평 확장 성, 내결함성, 빠른 속도를 자랑하며 수천 개의 회사에서 생산됩니다.</p><ul><li>메세지 브로커</li><li>High Throughtput</li><li>실시간 로그 통합</li><li>무중단(장비의 장애)</li><li>이기종과의 호환성</li><li>간단한 스케일 아웃</li><li>프로듀서와 컨슈머 역할 분리</li></ul><h4 id="성능-테스트시"><a href="#성능-테스트시" class="headerlink" title="성능 테스트시"></a>성능 테스트시</h4><ul><li>kafka (초당 300만) vs rabbitMQ (초당 100만)</li><li>kafka와 rabbitMQ의 가장 큰차이는 zookeeper가 있다는건가?</li><li>kafka에서는 producer와 consumer간에 topic으로만 메세지 처리</li><li>rabbitMQ는 ….. 복잡하데요</li></ul><h4 id="kafka의-성능"><a href="#kafka의-성능" class="headerlink" title="kafka의 성능"></a>kafka의 성능</h4><ul><li>message크기가 작을수록 성능이 좋다</li><li>broker가 많을수록 성능이 좋다</li><li>replica는 작을수록 성능이 좋다 - message가 중요하면 3으로 설정 * 손실되도 좋다라고 하면 1이나 2로 설정하는게 좋다</li><li>partition은 클수록 성능이 좋다 : 파티션 수는 늘리면 줄일수가 없다.</li></ul><h5 id="kakao-하루에-kafka가-얼마나-쓰이고있는지"><a href="#kakao-하루에-kafka가-얼마나-쓰이고있는지" class="headerlink" title="kakao - 하루에 kafka가 얼마나 쓰이고있는지?"></a>kakao - 하루에 kafka가 얼마나 쓰이고있는지?</h5><ul><li>(메세지처리량) 1800억건</li><li>205TB / day in</li><li>350 TB / day out</li><li>들어오는거보다 나가는양이많다?</li><li>단일토픽하나로 가장 처리량이 높았던건 초당 80만</li><li>2년 운영하면서 큰장애는 2건.</li></ul><h4 id="kakao-kafka사용시-장애-이슈"><a href="#kakao-kafka사용시-장애-이슈" class="headerlink" title="kakao kafka사용시 장애 이슈"></a>kakao kafka사용시 장애 이슈</h4><ul><li>ISR (In-Synk Replicas) 축소<ul><li>현재 복제되고있는구성원</li><li>리더만 읽고 쓰기</li><li>팔로워들은 리더를 주기적으로 동기화</li><li>ISR의 구성원만이 리더의 자격을 갖는다</li><li>isr축소 버그가 있음 (0.10.1.0)</li></ul></li><li>Rack Power<ul><li>broker는 idc랙별로 분산해서 놓는게 좋습니다.</li><li>장애또는 이슈로 인한 리더가 변경되는경우…..<ul><li>여러개의 broker가 있는 경우 장애로 리더가 자주 변경되게 되면 broker간의 sync 가 안맞게 된다 이경우 sync가 맞지 않은 broker가 장애로 인해 리더가 된다면……<br>기존 리더로 부터 메세지 복제가 이루어 져야 한다. 그런데 기존 리더가 올라오지 않는다면?????<br>기다려야 할지 아니면 먼저 올라온 broker가 리더로서의 역할을 해야 할지..</li></ul></li></ul></li></ul><h4 id="Use-Case-KaKao"><a href="#Use-Case-KaKao" class="headerlink" title="Use Case (KaKao)"></a>Use Case (KaKao)</h4><p>로그를 통합하고 싶어요<br>CS때문에 각 서버에서 Grep하고 있어요….</p><ul><li>MSA<br>단점?? 카프카를 쓰면 다 해결된데요 ㅋㅋㅋㅋ</li><li>RabbitMQ Log System<br>kibana</li></ul><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>손실없이 kafka로 보내는것</p><h5 id="Producer-ACKS"><a href="#Producer-ACKS" class="headerlink" title="Producer ACKS"></a>Producer ACKS</h5><ul><li>ACKS 는 크게 3가지 타입으로 나누어져있음 ( 0, 1, ALL)</li><li>0 : Message를 매우 빠르게 전송할수 있지만 리더가 받았는지 알수 없음</li><li>1 : Message전송도 빠른 편이고 파티션의 리더가 받았는지 확인 (가장많이 사용)</li><li>ALL : Message 전송은 느리지만 손실없는 전송 가능</li><li>1는 손실가능성이 있음….</li></ul><h5 id="ACK1은-안전한가"><a href="#ACK1은-안전한가" class="headerlink" title="ACK1은 안전한가?"></a>ACK1은 안전한가?</h5><p>리더가 메세지를 받고 저장후 producer에게 잘받았다고 전달을 하고<br>바로 리더가 down되는경우 (sync가 안맞는 경우)는… 손실이 일어날 수 있다.</p><h5 id="파티션…"><a href="#파티션…" class="headerlink" title="파티션…?"></a>파티션…?</h5><p>특정 파티션만 메세지를 못가져오고있어요<br>특정 파티션의 사이즈가 이상해요<br>Producer가 message를 보낼때 key value방식으로 보내는데<br>key를 안보낼 수 있다…<br>전송 방식은 RB<br>key를 주게 되는경우 특정 파티션으로 전달이 되는데<br>key가 중복이 되는경우…. ?</p><h5 id="컨슈머가-자꾸-죽는경우…"><a href="#컨슈머가-자꾸-죽는경우…" class="headerlink" title="컨슈머가 자꾸 죽는경우…"></a>컨슈머가 자꾸 죽는경우…</h5><p>ack 설정값을 잘봐요… 메세지 손실때문에 그런건가?</p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>브로커의 리더 파티션에서 message 를 가져오는역활</p><p>파티션이 하나일때 :<br>파티션의 오프셋 순서대로 가져 옵니다</p><p>파티션이 0개 이상일때 : 파티션별로 오프셋 순서대로 가져온다<br>한가지 보장할수 없는건 파티션 번호의 순서대로 가져오지 않는다.<br>파티션별루 오프셋 번호는 동일 (오프셋 0, 오프셋 1, 오프셋 2 …)</p><p>파티션이 늘어나면 성능이 좋은 장점은 있지만<br>message가 꼬일수 있다. (해결방법은 timestamp를 이용)</p><p>하나의 파티션에는 하나의 컨슈머만 가능?</p><p>컨슈머 그룹을 이용한 멀티 컨슈머</p><h5 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h5><p>컨슈머는 파티션의 몇번째 오프셋까지 가져왓는지 표시<br>이러한 행동을 commit 한다고 합<br>rebalancing이나 컨슈머 재시작시 commit된 위치부터 시작<br>auto commit / manual commit이 있다지만 auto commit을 사용<br>auto commit을 사용할 때 중복에 대한 예외처리를 해주면 좋다..</p><h5 id="LAG"><a href="#LAG" class="headerlink" title="LAG"></a>LAG</h5><p>Burrow : lag 체크 할수 있는 툴</p><h4 id="Operational-Tips"><a href="#Operational-Tips" class="headerlink" title="Operational Tips"></a>Operational Tips</h4><h5 id="파티션-수-늘려주세요"><a href="#파티션-수-늘려주세요" class="headerlink" title="파티션 수 늘려주세요 ??"></a>파티션 수 늘려주세요 ??</h5><p>파티션은 늘리면 줄일 수가 없어요…. 잘생각해서 늘려야함<br>lag이 밀린다면 partition을 늘려주는게 좋다. (파티션을 늘리면서 컨슈머를 늘려줘야함)</p><h5 id="디스크-공간이-부족해요"><a href="#디스크-공간이-부족해요" class="headerlink" title="디스크 공간이 부족해요??"></a>디스크 공간이 부족해요??</h5><p>retention.hours 168 (7일) - global<br>카프카 메세지 기본 보관값이 7일이에요<br>카카오는 3일로 줄여놨다고 합니다.<br>그중에 메세지 사이즈가 큰거는 별도로 줄이고 있다고 합니다.<br>retention.ms = 86400000 (1일)<br>토픽마다 보관 주기를 할 수 있어요</p><h5 id="scale-out"><a href="#scale-out" class="headerlink" title="scale out??"></a>scale out??</h5><p>기존 카프카를 복사하고 브로커 아이디만 유니크하게 바꿔서 올리면 되요?<br>새로운 추가 작업은 쉽지만<br>기존 운영중에 사용량이 많은 브로커에 대해 대안을 위한 스케일 아웃시에는<br>조금 복잡하다고 합니다 먼소린지 모르겠음</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;회사에 &lt;a href=&quot;https://aladin.co.kr/shop/wproduct.aspx?ItemId=142100738&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;카프카, 데이터 플랫폼의 최강자&lt;/a&gt; 책의 저자인 고승범 님이
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>oracle &gt; mysql migration(load data)</title>
    <link href="http://yoursite.com/2019/12/10/oracle%20%3E%20mysql%20migration(load%20data)/"/>
    <id>http://yoursite.com/2019/12/10/oracle%20%3E%20mysql%20migration(load%20data)/</id>
    <published>2019-12-10T01:15:49.393Z</published>
    <updated>2019-12-13T05:42:50.474Z</updated>
    
    <content type="html"><![CDATA[<p>2016년에 작업했던 기록 저장용<br>oracle &gt; mysql 과 같이 이기종간 마이그레이션은 지원하는 몇가지 툴이 있는것으로 알고있다.<br>사실 아는건 <a href="https://sourceforge.net/projects/pentaho/files/Data%20Integration/" target="_blank" rel="noopener">이것</a> 뿐이지만…<br>test를 해보니까 생각보다 너무느렸다.<br>서비스하는 회사에서 보통 주어지는 시간은 6시간 남짓이다. (이것도 내경험상 00시 ~ 06시)</p><p>예전에 oracle DBA로 일했었는데.<br>그 때 동기종 migration는 꽤 자주 했다.<br>물론 거의 대부분 export / import를 이용해서 했는데.<br>sqlldr을 이용해서 해봤는데 속도가 괜찮아서 mysql 에 동일한 명령어가 있는지 찾아봤다.</p><p>mysql <code>LOAD DATA</code> 를 사용하기로 했다.</p><h1 id="LOAD-DATA"><a href="#LOAD-DATA" class="headerlink" title="LOAD DATA"></a>LOAD DATA</h1><p><a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/load-data.html</a></p><h1 id="Oracle에서의-작업"><a href="#Oracle에서의-작업" class="headerlink" title="Oracle에서의 작업"></a>Oracle에서의 작업</h1><p>LOAD DATA는 특정 구분자로 되어있는 file을 insert를 반복하는 작업이다.<br>그러기 위해선 Table을 먼저 만들어야 했다.</p><h4 id="Table-생성"><a href="#Table-생성" class="headerlink" title="Table 생성"></a>Table 생성</h4><ul><li>Oracle 의 Table create script를 가져와서 아래 2가지 타입에 대해 변경 작업<ul><li>NUMBER TYPE -&gt; INT TYPE</li><li>VARCHAR2 TYPE -&gt; VARCHAR TYPE</li></ul></li><li>다른 TYPE도 확인해봐야한다. 내가 작업하는 DB는 저정도만 신경쓰면 됬다.</li><li>참고로 나는 java test case로 table 생성 스크립트를 가져와서 type 변환하는 코드를 만들었었다. </li></ul><h4 id="쿼리생성"><a href="#쿼리생성" class="headerlink" title="쿼리생성"></a>쿼리생성</h4><ul><li>select 절을 만들어 보자. (oracle 기준이다.)</li><li>Delimiter는 <code>|</code> 를 사용했다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ltrim</span>(sys_connect_by_path(column_name, <span class="string">'||''|''||'</span>), <span class="string">'||''|''||'</span>) column_name</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">column_name,</span><br><span class="line">row_number()</span><br><span class="line"><span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>) rn,</span><br><span class="line"><span class="keyword">count</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">num</span>) cnt</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">column_name,</span><br><span class="line"><span class="number">1</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> cols</span><br><span class="line"><span class="keyword">WHERE</span> table_name = <span class="string">'TABLE_NAME'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_id))</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">level</span> = cnt</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> rn = <span class="number">1</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> cnt = cnt <span class="keyword">AND</span> <span class="keyword">PRIOR</span> rn = rn - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="생성한-쿼리로-데이터-추출"><a href="#생성한-쿼리로-데이터-추출" class="headerlink" title="생성한 쿼리로 데이터 추출"></a>생성한 쿼리로 데이터 추출</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set line 200</span><br><span class="line">SQL&gt; set pagesize 0</span><br><span class="line">SQL&gt; spool treserve.txt</span><br><span class="line">SQL&gt; select column_a||'|'||column_b||'|'||column_c||'|'||...</span><br><span class="line">from table_name;</span><br></pre></td></tr></table></figure><h4 id="추출된-데이터-전송"><a href="#추출된-데이터-전송" class="headerlink" title="추출된 데이터 전송"></a>추출된 데이터 전송</h4><p>scp를 통해서 전송했었다.<br>참고로 나는 IDC경로가 달라서 로컬에 받은 후 이관하려는 서버로 scp전송했다.</p><h1 id="mysql에서의-작업"><a href="#mysql에서의-작업" class="headerlink" title="mysql에서의 작업"></a>mysql에서의 작업</h1><p>위 oracle 에서의 작업에서 table 생성 스크립트로 mysql에 table 생성이 되어있어야한다.</p><h4 id="Character-Set-변경"><a href="#Character-Set-변경" class="headerlink" title="Character Set 변경"></a>Character Set 변경</h4><p>테스트 해보니 한글이 깨지는 경우가 있어서 변경 해줘야 하는 것 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -c -f euc-kr -t utf-8 test.txt &gt; <span class="built_in">test</span>-utf8.txt</span><br></pre></td></tr></table></figure><h4 id="데이터-import"><a href="#데이터-import" class="headerlink" title="데이터 import"></a>데이터 import</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use theater;</span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA LOCAL INFILE '/oradata/migration/test_utf8.txt' </span><br><span class="line">INTO TABLE table_name</span><br><span class="line">FIELDS TERMINATED BY '|'</span><br><span class="line">IGNORE 1 LINES;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2016년에 작업했던 기록 저장용&lt;br&gt;oracle &amp;gt; mysql 과 같이 이기종간 마이그레이션은 지원하는 몇가지 툴이 있는것으로 알고있다.&lt;br&gt;사실 아는건 &lt;a href=&quot;https://sourceforge.net/projects/pen
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GitLab설치 (Docker)</title>
    <link href="http://yoursite.com/2019/11/28/GitLab%EC%84%A4%EC%B9%98%20(Docker)/"/>
    <id>http://yoursite.com/2019/11/28/GitLab%EC%84%A4%EC%B9%98%20(Docker)/</id>
    <published>2019-11-28T05:05:30.384Z</published>
    <updated>2020-01-31T07:11:46.031Z</updated>
    
    <content type="html"><![CDATA[<p>이전 포스팅에서는 GCP에 gitlab-ce를 설치해봤는데.<br>왜 docker를 사용하지 않았을까? 라는 생각을 해서<br>한번 시도해봤다.</p><p>이번 설치는 사내의 dev서버에서 진행했으며<br>설치된 gitlab-ce는 팀내 저장소 및 issue tracking으로 사용할 예정이다</p><h1 id="docker-설치-docker-compose-설치"><a href="#docker-설치-docker-compose-설치" class="headerlink" title="docker 설치 (docker-compose 설치)"></a>docker 설치 (docker-compose 설치)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum package update</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker install</span></span><br><span class="line">curl -fsSl https://get.docker.com/ | sudo sh</span><br></pre></td></tr></table></figure><h1 id="docker-compose-설치"><a href="#docker-compose-설치" class="headerlink" title="docker-compose 설치"></a>docker-compose 설치</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h1 id="docker-compose-yml-파일-생성"><a href="#docker-compose-yml-파일-생성" class="headerlink" title="docker-compose.yml 파일 생성"></a>docker-compose.yml 파일 생성</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'gitlab/gitlab-ce:lastest'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'gitlab.example.com'</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">GITLAB_OMNIBUS_CONFIG:</span></span><br><span class="line">            <span class="string">external_url</span> <span class="string">'http://gitlab.example.com:8929'</span></span><br><span class="line">            <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">2224</span></span><br><span class="line">            <span class="comment"># smtp 설정 gmail</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_enable']</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_address']</span> <span class="string">=</span> <span class="string">'smtp.gmail.com'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_port']</span> <span class="string">=</span> <span class="number">587</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_user_name']</span> <span class="string">=</span> <span class="string">'thinkub0219@gmail.com'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_password']</span> <span class="string">=</span> <span class="string">'이메일 비밀번호'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_domain']</span> <span class="string">=</span> <span class="string">'smtp.gmail.com'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_authentication']</span> <span class="string">=</span> <span class="string">'login'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_enable_starttls_auto']</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_tls']</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_openssl_verify_mode']</span> <span class="string">=</span> <span class="string">'peer'</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'2224:22'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'80:80'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'/home/gitlab/config:/etc/gitlab'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'/home/gitlab/logs:/var/log/gitlab'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'/home/gitlab/data:/var/opt/gitlab'</span></span><br></pre></td></tr></table></figure><ul><li>image : docker image 설정</li><li>restart : server restart시 해당 docker container 실행 여부</li><li>hostname : 사용하려는 hostname</li><li>enviroment : 설치되는 image의 설정<ul><li>해당 설정은 /etc/gitlab.gitlab.rb 에 들어갈 설정들에 대한 정의임</li></ul></li><li>ports : OSPort:dockerPort<ul><li>위 설정에서 보면 2224 포트는 Os port이고 해당 포트로 접근시 docker의 22번 port와 통신</li><li>컨테이너가 한번 실행 된 이후 포트추가는 불가하기때문에 잘 고려해야 함.</li></ul></li><li>volumes : docker container 내부 volume과 OS간 연결 경로 <ul><li>앞이 OS 경로, 뒤가 Docker container경로</li></ul></li></ul><h1 id="docker-compose로-설치"><a href="#docker-compose로-설치" class="headerlink" title="docker-compose로 설치"></a>docker-compose로 설치</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>간혹 아래와 같은 오류를 만날 수 있다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Couldn<span class="string">'t connect to Docker daemon at http+docker://localhost - is it running?</span></span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure><p>도커 데몬이 안돌고 있다 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: https://docs.docker.com</span><br></pre></td></tr></table></figure><p>dead 상태이니 running 상태로 바꿔보자</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="접속-확인"><a href="#접속-확인" class="headerlink" title="접속 확인"></a>접속 확인</h1><p>위 설정 한 External URL : port 정보로 접속을 해보면 접속이 잘된다.<br>로그인 계정은 <a href="mailto:admin@example.com" target="_blank" rel="noopener">admin@example.com</a> 으로 최초 로그인시 password를 입력하면 된다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>Email이 발송되지 않는 문제가 있다.<br>흠 이래저래 해보는데 되지 않아서 이부분은 좀더 확인 후에 포스팅 할 예정이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><blockquote><p>docs.gitlab.com/omnibus/docker<br>docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose<br>docs.docker.com/compose/install</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이전 포스팅에서는 GCP에 gitlab-ce를 설치해봤는데.&lt;br&gt;왜 docker를 사용하지 않았을까? 라는 생각을 해서&lt;br&gt;한번 시도해봤다.&lt;/p&gt;
&lt;p&gt;이번 설치는 사내의 dev서버에서 진행했으며&lt;br&gt;설치된 gitlab-ce는 팀내 저장소
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SonarQube를 이용한 코드리뷰 해보기</title>
    <link href="http://yoursite.com/2019/11/27/SonarQube%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0%20%ED%95%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>http://yoursite.com/2019/11/27/SonarQube%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0%20%ED%95%B4%EB%B3%B4%EA%B8%B0/</id>
    <published>2019-11-27T03:35:40.230Z</published>
    <updated>2019-12-13T05:42:52.574Z</updated>
    
    <content type="html"><![CDATA[<p>이전 회사에서 적용했던 sonaqube에 대해 정리한 내용이 있어서<br>블로그에 옮긴다.</p><h1 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube?"></a>SonarQube?</h1><p>SonarQube는 Java, C #, JavaScript, TypeScript, C / C ++, COBOL 등 20 개 이상의 프로그래밍 언어에서 버그, 코드 냄새? (code smells) 및 보안 취약성을 탐지하기 위해 코드의 정적 분석을 통해 자동 검토를 수행하는 오픈 소스 플랫폼입니다.<br>프로그램의 실제 실행 없이 코드를 분석하는 것</p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>돌아가기만 하면 되는 코드’는 개발자에게도, 프로젝트에도 전혀 도움이 되지 않습니다. 잘못된 코드는 또다른 잘못된 코드를 양상하고, 떨어지는 가독성과 높아지는 복잡도 덕분에 프로젝트 코드는 시간이 지남에 따라 점점 이해하기 힘든 모습이 되어갑니다. 개발자는 더 많은 노력과 시간이 필요해 지고, 프로젝트는 언제 터질지 모르는 폭탄을 품고 살아가게 됩니다.</p><p>때문에 프로그래밍에서도 잘못된 자세를 지적해 주고 제대로 개발 할 수 있도록 이끌어줄 방법들이 필요합니다. 개발자의 필수 도서라 불리는 책들은 몇번을 읽어도 손해 볼게 없습니다.</p><p>애자일 진영에서 강조하는 페어 프로그래밍, 몹 프로그래밍이나 코드 인스펙션 활동들 역시 좋은 대안이 될 수 있습니다. 이러한 문화를 이끌어 줄 수 있는 멘토가 있다면 빠른 시간내 코드의 품질이 좋아질 수 있습니다.<br>문제는 ‘사람 == 시간 == 돈’ 이기 때문에 제대로 된 개발을 위해서는 그만큼 많은 비용이 필요할 수 밖에 없습니다.</p><p>결국, 이러한 부분에 대한 고민 끝에, 비용이 추가로 들지 않으면서 코드의 품질을 검토하고 잘못된 부분을 옳은 방향으로 고칠 수 있도록 멘토링하는 다양한 도구들이 만들어졌습니다.</p><h1 id="SonarQube-1"><a href="#SonarQube-1" class="headerlink" title="SonarQube"></a>SonarQube</h1><p>SonarQube 플랫폼은 4개의 컴포넌트로 구성</p><ul><li>SonarQube Server</li><li>SonarQube Database</li><li>SonarQube Plugin</li><li>SonarQube Scanner<br><img src="/img/2019/11/27/20191127_01.png" alt="image01"></li></ul><h3 id="SonarQube-Server"><a href="#SonarQube-Server" class="headerlink" title="SonarQube Server"></a>SonarQube Server</h3><p>3가지의 메인 프로세스를 구동</p><ul><li>Web Server : 사용자들에게 분석 결과를 보여주고, SonarQube 설정 페이지를 제공합니다.</li><li>Search Server : Elasticsearch 서버를 사용하며, 사용자에게 검색기능을 제공합니다.</li><li>Compute Engine Server : 정적 분석 결과를 생성하고 이를 SonarQube Database를 통해 저장합니다.</li></ul><h3 id="SonarQube-Database"><a href="#SonarQube-Database" class="headerlink" title="SonarQube Database"></a>SonarQube Database</h3><p>SonarQube의 기본 설정들(보안, Plugin 정보 등)과 프로젝트 분석 스냅샷들을 저장합니다. 설치시, 기본으로 H2 DB를 포함하며, 설정을 통해 다양한 DB 사용이 가능합니다</p><h3 id="SonarQube-Plugin"><a href="#SonarQube-Plugin" class="headerlink" title="SonarQube Plugin"></a>SonarQube Plugin</h3><p>내부에서 사용하는 다양한 기능(분석 프로그램언어, 권한, 관리, SCM등)을 플러그인 형태로 설치 가능합니다.</p><h3 id="SonarQube-Scanner"><a href="#SonarQube-Scanner" class="headerlink" title="SonarQube Scanner"></a>SonarQube Scanner</h3><p>프로젝트 정적 분석을 수행하는 툴로 다양한 형식으로 제공되며 CI Server와 연계하여 사용이 가능합니다.</p><h1 id="SonarQube-Integration"><a href="#SonarQube-Integration" class="headerlink" title="SonarQube Integration"></a>SonarQube Integration</h1><p><img src="/img/2019/11/27/20191127_02.png" alt="image02"></p><ol><li>개발자는 IDE에서 코드를 작성하고, Sonar Lint등을 통해 로컬에서 코드 분석을 실행합니다.</li><li>개발자는 분석을 통해 수정된 완성코드를 SCM으로 Push 합니다.</li><li>CI 서버에서 트리거된 빌드 수행시 SonarQube Scanner를 실행합니다.</li><li>SonarQube Scanner는 생성한 분석 리포트의 처리를 위해 SonarQube로 전송합니다.</li><li>SonarQube Server는 분석 리포트 결과를 처리하여 DB에 저장하고 결과를 웹서버를 통해 제공합니다.</li><li>개발자는 웹페이지에서 분석결과를 확인하여 코드를 개선합니다.<br>관리자는 결과 보고서를 받습니다.</li><li>SonarQube에서 데이터를 추출하기위해 API를 활용하거나 SonarQube Server 모니터링을 위해 JMX를 사용할 수 있습니다</li></ol><h1 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h1><h3 id="Maven-설치"><a href="#Maven-설치" class="headerlink" title="Maven 설치"></a>Maven 설치</h3><p>기본적으로 Maven의 H2DB를 사용 &gt; SonarQube를 설치하기 전에 Maven부터 설치 해줘야 한다</p><h3 id="SonarQube-설치"><a href="#SonarQube-설치" class="headerlink" title="SonarQube 설치"></a>SonarQube 설치</h3><p>파일을 받아서 압축을 해제하면 끝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir sonar-qube</span><br><span class="line"><span class="built_in">cd</span> sonar-qube</span><br><span class="line">wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-6.7.5.zip</span><br><span class="line"></span><br><span class="line">unzip sonarqube-6.7.5.zip</span><br></pre></td></tr></table></figure><h3 id="SonarQube-Start"><a href="#SonarQube-Start" class="headerlink" title="SonarQube Start"></a>SonarQube Start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sonarqube-6.7.5/bin/linux-x86-64</span><br><span class="line">./sonar.sh start</span><br></pre></td></tr></table></figure><p>기본적으로 9000포트를 사용하고 있으니 다른 포트를 사용하려면 sonar.properties 수정하면된다.</p><h3 id="SonarQube-Scanner-설치"><a href="#SonarQube-Scanner-설치" class="headerlink" title="SonarQube Scanner 설치"></a>SonarQube Scanner 설치</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://sonarsource.bintray.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-3.0.3.778-linux.zip</span><br><span class="line"></span><br><span class="line">unzip sonar-scanner-cli-3.0.3.778-linux.zip</span><br></pre></td></tr></table></figure><h3 id="Jenkins-연동"><a href="#Jenkins-연동" class="headerlink" title="Jenkins 연동"></a>Jenkins 연동</h3><p>Jenkins 설치는 Skip</p><h3 id="Jenkins-Pluggin-설치"><a href="#Jenkins-Pluggin-설치" class="headerlink" title="Jenkins Pluggin 설치"></a>Jenkins Pluggin 설치</h3><ul><li>Python Plugin</li><li>GitHub Pull Request Builder</li><li>GitHub plugin</li><li>SonarQube Scanner for Jenkins</li></ul><p>SonarQube Scanner for Jenks 의 경우 Jenkins 버전체크를 해줘야 한다.<br><img src="/img/2019/11/27/20191127_03.png" alt="image03"></p><p>플러그인 설치가능 목록에 안나오는 경우가 있으니 이런 경우 아래 url 에서 Archives 를 받아서 올려도됨<br><a href="https://plugins.jenkins.io/sonar" target="_blank" rel="noopener">https://plugins.jenkins.io/sonar</a><br><img src="/img/2019/11/27/20191127_04.png" alt="image04"></p><h3 id="Jenkins-SonarQube-server-정보-등록"><a href="#Jenkins-SonarQube-server-정보-등록" class="headerlink" title="Jenkins SonarQube server 정보 등록"></a>Jenkins SonarQube server 정보 등록</h3><p>server url 정보에 sonarQube 서버 url 을 넣는다<br><img src="/img/2019/11/27/20191127_05.png" alt="image05"></p><h3 id="Server-authentication-token"><a href="#Server-authentication-token" class="headerlink" title="Server authentication token"></a>Server authentication token</h3><p>Server authentication token 은 sonarQube를 접속해서 admin (password : admin) 으로 접속하면 아래 화면처럼 생성 할 수 있다.<br><img src="/img/2019/11/27/20191127_06.png" alt="image06"></p><h3 id="Jenkins-SonarQube-scanner-정보-등록"><a href="#Jenkins-SonarQube-scanner-정보-등록" class="headerlink" title="Jenkins SonarQube scanner 정보 등록"></a>Jenkins SonarQube scanner 정보 등록</h3><p>jenkins &gt; configure tools<br><img src="/img/2019/11/27/20191127_07.png" alt="image07"></p><h3 id="Github과-Jenkins-연동"><a href="#Github과-Jenkins-연동" class="headerlink" title="Github과 Jenkins 연동"></a>Github과 Jenkins 연동</h3><p>SKIP</p><h3 id="어떻게-써볼까요"><a href="#어떻게-써볼까요" class="headerlink" title="어떻게 써볼까요?"></a>어떻게 써볼까요?</h3><ul><li>Jenkins Build 할때?</li><li>Pull Request 할때?</li><li>Local 에서?</li></ul><h3 id="Jenkins-Build-with-SonarQube"><a href="#Jenkins-Build-with-SonarQube" class="headerlink" title="Jenkins Build (with SonarQube)"></a>Jenkins Build (with SonarQube)</h3><p>Jenkins Sonar-scanner<br>Jenkins 에서 build 시 Sonar-scanner 설정법<br><img src="/img/2019/11/27/20191127_08.png" alt="image08"></p><h3 id="Pull-Request-with-SonarQube"><a href="#Pull-Request-with-SonarQube" class="headerlink" title="Pull Request (with SonarQube)"></a>Pull Request (with SonarQube)</h3><p><img src="/img/2019/11/27/20191127_09.png" alt="image09"><br>해당 구조를 사용하기 위해선 GitHub WebHook사용과 Jenkins에 2개의 Job이 필요하다</p><ul><li>Jenkins Job<ul><li>1번 job : pullrequest_receiver : github으로부터 web-hook을 통해 pullRequest정보를 받는 job</li><li>2번 job : sonaqube-job : 1번 job으로 부터 정보를 받아 SonarQube를 이용해 정적분석후 해당 pullRequest에 댓글로 리포팅 하는 Job</li></ul></li><li>GitHub WebHook<ul><li>Github에서 Jenkins Job을 호출하기 위해서는 Jenkins가 외부에 공개되어 있어야 한다</li></ul></li></ul><h3 id="SonarLint-IntelliJ"><a href="#SonarLint-IntelliJ" class="headerlink" title="SonarLint (IntelliJ)"></a>SonarLint (IntelliJ)</h3><p>위와 같은 방법으로 SonarQube를 사용한다면…<br>코드를 작성하고 commit / push 이후에나 정적분석 피드백을 받을 수 있다.</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><p>Setting &gt; plugins &gt; Search in repositories<br>SonarLint 검색<br><img src="/img/2019/11/27/20191127_10.png" alt="image10"></p><h4 id="SonarQube-서버-연동"><a href="#SonarQube-서버-연동" class="headerlink" title="SonarQube 서버 연동"></a>SonarQube 서버 연동</h4><p>기본적인 설정만으로도 충분히 사용할 수 있으며 sonarqube 서버가 없어도 사용에 문제가 없습니다.<br>setting &gt; Other Settings &gt; SonarLing General Settings<br><img src="/img/2019/11/27/20191127_11.png" alt="image11"></p><p>참고</p><blockquote><p><a href="https://www.sonarqube.org/about/" target="_blank" rel="noopener">https://www.sonarqube.org/about/</a><br><a href="http://lazyrodi.github.io/2017/02/06/2017-02-06-etc-install-sonarqube/" target="_blank" rel="noopener">http://lazyrodi.github.io/2017/02/06/2017-02-06-etc-install-sonarqube/</a><br><a href="https://medium.com/@cgpink/소스-정적-분석도구-sonarqube-리서칭-9d48fc62b01f" target="_blank" rel="noopener">https://medium.com/@cgpink/소스-정적-분석도구-sonarqube-리서칭-9d48fc62b01f</a><br><a href="https://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/" target="_blank" rel="noopener">https://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이전 회사에서 적용했던 sonaqube에 대해 정리한 내용이 있어서&lt;br&gt;블로그에 옮긴다.&lt;/p&gt;
&lt;h1 id=&quot;SonarQube&quot;&gt;&lt;a href=&quot;#SonarQube&quot; class=&quot;headerlink&quot; title=&quot;SonarQube?&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GitLab설치 (GCP)</title>
    <link href="http://yoursite.com/2019/11/26/GitLab%EC%84%A4%EC%B9%98%20(GCP)/"/>
    <id>http://yoursite.com/2019/11/26/GitLab%EC%84%A4%EC%B9%98%20(GCP)/</id>
    <published>2019-11-26T04:18:30.667Z</published>
    <updated>2019-12-13T05:42:43.004Z</updated>
    
    <content type="html"><![CDATA[<p>최근 이직을 했는데.<br>이전 회사는 웹서비스를 하는 회사였고, 이직한 회사는 AI 하는 회사였다<br>물론 내가 담당한 업무는 웹개발이라서 업무가 달라지진 않았지만 환경이 달랐다</p><p>이전 회사는 모기업의 영향을 받아 Issue관리는 자체개발 솔루션을 사용했고<br>SCM은 git enterprise를 사용하는 등 나름 괜찮은 환경이었다.</p><p>이직한 회사는 svn을 사용하고 Issue관리는 그냥 메일로 하고,<br>IntelliJ 도 개인라이선스를 구매하는 등. 좀 열악한 편이었다.</p><p>그 중 제일 불편한게 Issue관리!!<br>메일로 주고 받다 보니 이런 저런 메일이 오면서 History추적이 어려웠다.</p><h1 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h1><p>예전 N사와 API 연동 작업을 한적이 있는데.<br>이때 Gitlab을 이용해서 Issue관리를 했었다.<br>상당히 괜찮았던 기억이 있어서 Gitlab을 설치해보기로 했다.</p><h3 id="어디에-설치하지"><a href="#어디에-설치하지" class="headerlink" title="어디에 설치하지?!"></a>어디에 설치하지?!</h3><p>아직 회사에다가 내가 Gitlab을 설치하고 싶으니 서버를 주세요.<br>라고 말하기가 어려운 상태다 (아직 이직 1달이 되지 않았다 ㅠ)<br>aws가 1년간 무료이니 거기에 설치해 보려했으나….<br>aws프리티어 인스턴스를 만들다 보면 지원되는 CPU와 메모리가 1core 에 1GB이다.<br>gitlab의 경우 최소 2core CPU와 4GB의 RAM을 권장한다.<br>혹시나 하는 마음에 aws에 설치해 봤으나 아래와 같은 문구를 만나게 되었다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot allocate memory - fork(2)</span><br></pre></td></tr></table></figure><p>그래서 선택한건 구글 클라우드.<br>구글 클라우드의 경우 무료 크레딧($300)을 준 다음.<br>해당 크레딧을 사용하는 한도에서는 어떤 스펙의 장비를 써도 된다.</p><h1 id="GCP-Compute-Engine"><a href="#GCP-Compute-Engine" class="headerlink" title="GCP Compute Engine"></a>GCP Compute Engine</h1><ol><li><p>google cloud platform 사이트에 로그인 후 Compute Engine선택<br><img src="/img/2019/11/26/20191126_01.png" alt="image01"></p></li><li><p>VM 인스턴스 만들기<br><img src="/img/2019/11/26/20191126_02.png" alt="image02"></p></li><li><p>옵션 선택 (옵션 선택에 따른 비용이 달라진다 오른쪽에 표시)</p><ul><li>이름 : 사용하고자 하는 서버명을 적는다 나는 gitlab을 적었다.</li><li>리전 : 리전에 따라 사용비용이 다르다. 이건 개인 취향으로.</li><li>영역 : 그냥 Defalut로</li><li>시리즈 : N1 선택 이것도 선택에 따라 비용이 달라진다.<br>(N2의 경우 최소사양이 CPU 2, 8GB메모리라 N1을 선택했다.)</li><li>머신유형 : 최소사양으로 해보았다. CPU 2개, 7.5GB</li><li>그외 : 기본을 사용하고 HTTP, HTTPS 트래픽 허용<br><img src="/img/2019/11/26/20191126_03.png" alt="image03"></li></ul></li><li><p>만들기를 누르기전 OS이미지를 선택하자</p><ul><li>옵션 중 부팅디스크의 변경 선택</li><li>Ubuntu 16.04 LTS를 선택한다.</li><li>SSD 영구디스크를 선택하고 크기는 40GB정도로 잡는다.<br><img src="/img/2019/11/26/20191126_04.png" alt="image04"></li></ul></li></ol><h1 id="Gitlab-설치"><a href="#Gitlab-설치" class="headerlink" title="Gitlab 설치"></a>Gitlab 설치</h1><p>방금 생성한 Instance에 Gitlab을 설치해보자<br><img src="/img/2019/11/26/20191126_05.png" alt="image05"></p><ol><li>ssh버튼을 누르면 콘솔창이 열린다.<br><img src="/img/2019/11/26/20191126_06.png" alt="image06"></li></ol><ol start="2"><li><p>필요한 Dependency를 설치 및 Update</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br></pre></td></tr></table></figure></li><li><p>Gitlab 패키지 Repository 추가 및 패키지 설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure></li><li><p>저장소 목록 업데이트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>Gitlab CE설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><ul><li>설치가 완료되면 아래와 같은 로고가 보인다.<br><img src="/img/2019/11/26/20191126_07.png" alt="image07"></li></ul></li></ol><ol start="6"><li>Gitlab 초기설정<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li></ol><h1 id="Gitlab-설정"><a href="#Gitlab-설정" class="headerlink" title="Gitlab 설정"></a>Gitlab 설정</h1><p>Gitlab 관련 설정파일은 /etc/gitlab.gitlab.rb 파일에서 할 수 있다.<br>external_url 만 바꿔 보겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure><p>설정 완료후 설정 적용 및 재시작을 해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><h1 id="접속테스트"><a href="#접속테스트" class="headerlink" title="접속테스트"></a>접속테스트</h1><p><img src="/img/2019/11/26/20191126_08.png" alt="image08"></p><h1 id="참고-Site"><a href="#참고-Site" class="headerlink" title="참고 Site"></a>참고 Site</h1><blockquote><p>docs.gitlab.com/ce/install/google_cloud_platform<br>docs.gitlab.com/ce/README.html</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;최근 이직을 했는데.&lt;br&gt;이전 회사는 웹서비스를 하는 회사였고, 이직한 회사는 AI 하는 회사였다&lt;br&gt;물론 내가 담당한 업무는 웹개발이라서 업무가 달라지진 않았지만 환경이 달랐다&lt;/p&gt;
&lt;p&gt;이전 회사는 모기업의 영향을 받아 Issue관리는 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mongo DB설치하기 (Feat. Docker)</title>
    <link href="http://yoursite.com/2019/11/25/mongo%20DB%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0%20(Feat.%20Docker)/"/>
    <id>http://yoursite.com/2019/11/25/mongo%20DB%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0%20(Feat.%20Docker)/</id>
    <published>2019-11-25T04:05:04.135Z</published>
    <updated>2019-11-26T04:13:12.020Z</updated>
    
    <content type="html"><![CDATA[<p>일전에 프로젝트 하나를 진행하게 되었는데.<br>DB의 로우데이터를 특정 조건에 맞게 집계를 해야했다.<br>프로젝트 규모나 사용성을 봤을때는<br>rdbms로 작업해도 크게 무리가 되지 않는 스펙이었다<br>근데 주변 동료들이 no-sql로 하는건 어떠냐고 해서 한번 해보기로 했다.</p><h1 id="DB-선택하기"><a href="#DB-선택하기" class="headerlink" title="DB 선택하기"></a>DB 선택하기</h1><p>먼저 어떤 db engine이 가장 많이 사용되는지 검색해 봤다<br><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">여기</a> 에서 확인 해보니 Document 기반으로는 MongoDB 순위가 높았다<br>통계 Data 특성상 스키마간 RelationShip이 크게 필요하지 않을 것이라 생각해서 MongoDB로 해보기로 했다<br><img src="/img/docker-mongo1.png" width="700px" ></img></p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB ?"></a>MongoDB ?</h1><blockquote><p>MongoDB는 필요한 쿼리 및 인덱싱을 통해 원하는 확장성과 유연성을 갖춘 문서 데이터베이스입니다.</p></blockquote><ul><li>MongoDB는 데이터를 유연한 JSON 형식의 문서로 저장합니다. 즉, 필드마다 문서마다 다를 수 있으며 시간이 지남에 따라 데이터 구조가 변경 될 수 있습니다.</li><li>문서 모델은 응용 프로그램 코드의 개체에 매핑되므로 데이터를 쉽게 사용할 수 있습니다.</li><li>임시 질의, 인덱싱 및 실시간 집계는 데이터 액세스 및 분석을위한 강력한 방법을 제공합니다.</li><li>MongoDB는 핵심적인 분산 데이터베이스이므로 고 가용성, 수평 확장 및 지리적 분포가 내장되어 사용하기 쉽습니다.</li><li>MongoDB는 무료이며 오픈 소스이며, GNU Affero General Public License</li></ul><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ol><li>Document-oriented storage : MongoDB는 database &gt; collections &gt; documents 구조로 document는 key-value형태의 BSON(Binary JSON)으로 되어있다</li><li>Full Index Support : 다양한 인덱싱을 제공한다.<ol><li>Single Field Indexes : 기본적인 인덱스 타입</li><li>Compound Indexes : RDBMS의 복합인덱스 같은 거</li><li>Multikey Indexes : Array에 매칭되는 값이 하나라도 있으면 인덱스에 추가하는 멀티키 인덱스</li><li>Geospatial Indexes and Queries : 위치기반 인덱스와 쿼리</li><li>Text Indexes : String에도 인덱싱이 가능</li><li>Hashed Index : Btree 인덱스가 아닌 Hash 타입의 인덱스도 사용 가능</li></ol></li><li>Replication&amp; High Availability : 간단한 설정만으로도 데이터 복제를 지원. 가용성 향상</li><li>Auto-Sharding : MongoDB는 처음부터 자동으로 데이터를 분산하여 저장하며, 하나의 컬렉션처럼 사용할 수 있게 해준다. 수평적 확장 가능</li><li>Querying(documented-based query) : 다양한 종류의 쿼리문 지원. (필터링, 수집, 정렬, 정규표현식 등)</li><li>Fast In-Pace Updates : 고성능의 atomic operation을 지원</li><li>Map/Reduce : 맵리듀스를 지원.(map과 reduce 함수의 조합을 통해 분산/병렬 시스템 운용 지원, 하둡처럼 MR전용시스템에 비해서는 성능이 떨어진다)</li><li>GridFS : 분산파일 저장을 MongoDB가 자동으로 해준다. 실제 파일이 어디에 저장되어 있는지 신경 쓸 필요가 없고 복구도 자동이다.</li><li>Commercial Support : 10gen에서 관리하는 오픈소스</li></ol><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ol><li>Flexibility : Schema-less라서 어떤 형태의 데이터라도 저장할 수 있다.</li><li>Performance : Read &amp; Write 성능이 뛰어나다. 캐싱이나 많은 트래픽을 감당할 때 써도 좋다.</li><li>Scalability : 애초부터 스케일아웃 구조를 채택해서 쉽게 운용가능하다. Auto sharding 지원</li><li>Deep Query ability : 문서지향적 Query Language 를 사용하여 SQL 만큼 강력한 Query 성능을 제공한다.</li><li>Conversion / Mapping : JSON형태로 저장이 가능해서 직관적이고 개발이 편리하다.</li></ol><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><ol><li>정합성이 떨어지므로 트랜잭션이 필요한 경우에는 부적합하다. (ex. 금융, 결제, 회원정보 등)</li><li>JOIN이 없다. join이 필요없도록 데이터 구조화 필요</li><li>memory mapped file으로 파일 엔진 DB이다. 메모리 관리를 OS에게 위임한다. 메모리에 의존적, 메모리 크기가 성능을 좌우한다. 2-4를 참고하자.</li><li>SQL을 완전히 이전할 수는 없다.</li><li>B트리 인덱스를 사용하여 인덱스를 생성하는데, B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 저하된다. 이런 B트리의 특성 때문에 데이터를 넣어두면 변하지않고 정보를 조회하는 데에 적합하다.</li></ol><h1 id="MongoDB-설치-Feat-Docker"><a href="#MongoDB-설치-Feat-Docker" class="headerlink" title="MongoDB 설치 (Feat. Docker)"></a>MongoDB 설치 (Feat. Docker)</h1><p>사전 설치 서버에 Docker설치를 해야한다.<br>이전 회사 특성상 root권한이 없었기에 관리자에게 설치 요청</p><h3 id="Image-Download"><a href="#Image-Download" class="headerlink" title="Image Download"></a>Image Download</h3><p>필요한 Image는 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 에서 검색이 가능하다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><p>Download 된 이미지 확인</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="Image-생성"><a href="#Image-생성" class="headerlink" title="Image 생성"></a>Image 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mongo:tl_mongo .</span><br></pre></td></tr></table></figure><h3 id="Container-생성"><a href="#Container-생성" class="headerlink" title="Container 생성"></a>Container 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 27017:27017 -v /home1/irteam/mongo/data:/data/db --name ubuntu --net=host -e MONGO_INITDB_ROOT_USERNAME=id입력부분 -e MONGO_INITDB_ROOT_PASSWORD=<span class="built_in">pwd</span>입력부분 mongo --auth--auth</span><br></pre></td></tr></table></figure><h3 id="인증모드로-mongo접속"><a href="#인증모드로-mongo접속" class="headerlink" title="인증모드로 mongo접속"></a>인증모드로 mongo접속</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &#123;containerId&#125; mongo -u id입력부분 -p <span class="built_in">pwd</span>입력부분 -authenticationDatabase admin</span><br></pre></td></tr></table></figure><ul><li><p>admin 계정 생성후 사용계정 별도 생성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use 생성DB명</span><br><span class="line"></span><br><span class="line">db.createUser(</span><br><span class="line">    &#123;</span><br><span class="line">        user: mongoDB유저ID,</span><br><span class="line">        <span class="built_in">pwd</span>: mongoDB유저PWD,</span><br><span class="line">        roles: [</span><br><span class="line">            &#123;</span><br><span class="line">                role: <span class="string">"readWrite"</span>,</span><br><span class="line">                db: 생성DB명</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>생성된 계정으로 접속</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 컨테이너ID mongo -u mongoDB유저ID -p mongoDB유저PWD -authenticationDatabase 생성DB명</span><br></pre></td></tr></table></figure></li></ul><h3 id="MongoDB-Compass"><a href="#MongoDB-Compass" class="headerlink" title="MongoDB Compass"></a>MongoDB Compass</h3><p>워크벤치나 토드같은 client 도구이다<br><a href="https://www.mongodb.com/download-center/compass" target="_blank" rel="noopener">https://www.mongodb.com/download-center/compass</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;일전에 프로젝트 하나를 진행하게 되었는데.&lt;br&gt;DB의 로우데이터를 특정 조건에 맞게 집계를 해야했다.&lt;br&gt;프로젝트 규모나 사용성을 봤을때는&lt;br&gt;rdbms로 작업해도 크게 무리가 되지 않는 스펙이었다&lt;br&gt;근데 주변 동료들이 no-sql로 하
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring-boot War 배포</title>
    <link href="http://yoursite.com/2019/11/22/Spring-boot%20War%20%EB%B0%B0%ED%8F%AC/"/>
    <id>http://yoursite.com/2019/11/22/Spring-boot%20War%20%EB%B0%B0%ED%8F%AC/</id>
    <published>2019-11-22T06:24:58.395Z</published>
    <updated>2019-11-22T06:43:12.423Z</updated>
    
    <content type="html"><![CDATA[<p>아주 간단한 프로젝트 진행요청이 왔다.<br>간단히 spring-boot로 프로젝트를 생성해서 진행을 했다<br>결과물을 전달하려고 하는데 war파일로 달라는거다</p><h1 id="pom-xml-설정"><a href="#pom-xml-설정" class="headerlink" title="pom.xml 설정"></a>pom.xml 설정</h1><h3 id="packaging-설정"><a href="#packaging-설정" class="headerlink" title="packaging 설정"></a>packaging 설정</h3><p>보통 spring-boot 로 프로젝트를 만들면 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>로 되어있거나 해당 설정 부분이 없는 경우도 있다 <br><br>이 부분을 아래와 같이 수정해준다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="톰켓-배포용-라이브러리-dependency-추가"><a href="#톰켓-배포용-라이브러리-dependency-추가" class="headerlink" title="톰켓 배포용 라이브러리 dependency 추가"></a>톰켓 배포용 라이브러리 dependency 추가</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="SpringBootServletInitialLizer-작성"><a href="#SpringBootServletInitialLizer-작성" class="headerlink" title="SpringBootServletInitialLizer 작성"></a>SpringBootServletInitialLizer 작성</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitiallizer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder applicationBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationBuilder.sources(DocHelperApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>끗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;아주 간단한 프로젝트 진행요청이 왔다.&lt;br&gt;간단히 spring-boot로 프로젝트를 생성해서 진행을 했다&lt;br&gt;결과물을 전달하려고 하는데 war파일로 달라는거다&lt;/p&gt;
&lt;h1 id=&quot;pom-xml-설정&quot;&gt;&lt;a href=&quot;#pom-xml-설정&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>github 블로그만들기 (Feat. hexo)</title>
    <link href="http://yoursite.com/2019/11/21/github%20%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A7%8C%EB%93%A4%EA%B8%B0%20(Feat.hexo)/"/>
    <id>http://yoursite.com/2019/11/21/github%20%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A7%8C%EB%93%A4%EA%B8%B0%20(Feat.hexo)/</id>
    <published>2019-11-21T08:50:12.743Z</published>
    <updated>2019-12-13T05:42:37.590Z</updated>
    
    <content type="html"><![CDATA[<p>기억력이 좋지 못해서, 무언가 알게된 지식을 기존엔 evernote에 저장을 했었다.<br>차곡차곡 문서가 쌓이다보니…. 뭘 작성한지도 작성한걸 찾지도 못하는 나를 발견하여<br>느지막이 github 블로그를 만들어 보기로 결심. hexo를 이용해보기로 했다.</p><h1 id="github-repository-생성"><a href="#github-repository-생성" class="headerlink" title="github repository 생성"></a>github repository 생성</h1><ul><li>repository 명칭은 USERNAME.github.io 로 생성 (thinkub.github.io)</li><li>Description 은 마음데로</li><li>public 설정하고</li><li>README 파일은 생성한다.<br>  <img src="/img/screenshot01.png" width="500px" ></img></li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul><li><p>git clone<br>먼저 생성한 blog용 git repository를 clone한다</p></li><li><p>hexo 설치<br><img src="/img/hexo01.png" width="500px" ></img></p><ul><li><p>clone 한 경로에 blog 라는 폴더로 hexo 를 init</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></li><li><p>첨부된 이미지 처럼 blog 라는 경로가 생김<br><img src="/img/hexo02.png" width="200px" ></img>   </p></li><li><p>local 에서 확인하기</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="/img/hexo04.png" width="100%" ></img></p></li></ul></li><li><p>theme 적용<br><a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">여기</a> 에서 원하는 걸 고르면된다.<br>나는 <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank" rel="noopener">clean-blog</a> 를 사용하기로 했음</p><ul><li><p>선택한 theme repository git clon<br><img src="/img/hexo05.png" width="100%" ></img></p></li><li><p>theme 적용<br><img src="/img/hexo06.png" width="100%" ></img></p></li></ul></li><li><p>github 동기화</p><ul><li><p>/blog/_config.yml 파일을 보면 Deploy 설정하는 곳이 있다 여기에 설정<br><img src="/img/hexo07.png" width="100%" ></img></p></li><li><p>public 파일 변환<br><img src="/img/hexo08.png" width="100%" ></img></p></li><li><p>git에 올리기</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;기억력이 좋지 못해서, 무언가 알게된 지식을 기존엔 evernote에 저장을 했었다.&lt;br&gt;차곡차곡 문서가 쌓이다보니…. 뭘 작성한지도 작성한걸 찾지도 못하는 나를 발견하여&lt;br&gt;느지막이 github 블로그를 만들어 보기로 결심. hexo를 이용
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
