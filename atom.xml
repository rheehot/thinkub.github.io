<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>개인 저장소</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-11T00:55:32.074Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>oracle &gt; mysql migration(load data)</title>
    <link href="http://yoursite.com/2019/12/10/oracle%20%3E%20mysql%20migration(load%20data)/"/>
    <id>http://yoursite.com/2019/12/10/oracle%20%3E%20mysql%20migration(load%20data)/</id>
    <published>2019-12-10T01:15:49.393Z</published>
    <updated>2019-12-11T00:55:32.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="사설"><a href="#사설" class="headerlink" title="사설"></a>사설</h1><p>2016년에 작업했던 기록 저장용<br>oracle &gt; mysql 과 같이 이기종간 마이그레이션은 지원하는 몇가지 툴이 있는것으로 알고있다.<br>사실 아는건 <a href="https://sourceforge.net/projects/pentaho/files/Data%20Integration/" target="_blank" rel="noopener">이것</a> 뿐이지만…<br>test를 해보니까 생각보다 너무느렸다.<br>서비스하는 회사에서 보통 주어지는 시간은 6시간 남짓이다. (이것도 내경험상 00시 ~ 06시)</p><p>예전에 oracle DBA로 일했었는데.<br>그 때 동기종 migration는 꽤 자주 했다.<br>물론 거의 대부분 export / import를 이용해서 했는데.<br>sqlldr을 이용해서 해봤는데 속도가 괜찮아서 mysql 에 동일한 명령어가 있는지 찾아봤다.</p><p>mysql <code>LOAD DATA</code> 를 사용하기로 했다.</p><h1 id="LOAD-DATA"><a href="#LOAD-DATA" class="headerlink" title="LOAD DATA"></a>LOAD DATA</h1><p><a href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/load-data.html</a></p><h1 id="Oracle에서의-작업"><a href="#Oracle에서의-작업" class="headerlink" title="Oracle에서의 작업"></a>Oracle에서의 작업</h1><p>LOAD DATA는 특정 구분자로 되어있는 file을 insert를 반복하는 작업이다.<br>그러기 위해선 Table을 먼저 만들어야 했다.</p><h4 id="Table-생성"><a href="#Table-생성" class="headerlink" title="Table 생성"></a>Table 생성</h4><ul><li>Oracle 의 Table create script를 가져와서 아래 2가지 타입에 대해 변경 작업<ul><li>NUMBER TYPE -&gt; INT TYPE</li><li>VARCHAR2 TYPE -&gt; VARCHAR TYPE</li></ul></li><li>다른 TYPE도 확인해봐야한다. 내가 작업하는 DB는 저정도만 신경쓰면 됬다.</li><li>참고로 나는 java test case로 table 생성 스크립트를 가져와서 type 변환하는 코드를 만들었었다. </li></ul><h4 id="쿼리생성"><a href="#쿼리생성" class="headerlink" title="쿼리생성"></a>쿼리생성</h4><ul><li>select 절을 만들어 보자. (oracle 기준이다.)</li><li>Delimiter는 <code>|</code> 를 사용했다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ltrim</span>(sys_connect_by_path(column_name, <span class="string">'||''|''||'</span>), <span class="string">'||''|''||'</span>) column_name</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">column_name,</span><br><span class="line">row_number()</span><br><span class="line"><span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">num</span>) rn,</span><br><span class="line"><span class="keyword">count</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">num</span>) cnt</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">column_name,</span><br><span class="line"><span class="number">1</span> <span class="keyword">num</span></span><br><span class="line"><span class="keyword">FROM</span> cols</span><br><span class="line"><span class="keyword">WHERE</span> table_name = <span class="string">'TABLE_NAME'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_id))</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">level</span> = cnt</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> rn = <span class="number">1</span></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">PRIOR</span> cnt = cnt <span class="keyword">AND</span> <span class="keyword">PRIOR</span> rn = rn - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="생성한-쿼리로-데이터-추출"><a href="#생성한-쿼리로-데이터-추출" class="headerlink" title="생성한 쿼리로 데이터 추출"></a>생성한 쿼리로 데이터 추출</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; set line 200</span><br><span class="line">SQL&gt; set pagesize 0</span><br><span class="line">SQL&gt; spool treserve.txt</span><br><span class="line">SQL&gt; select column_a||'|'||column_b||'|'||column_c||'|'||...</span><br><span class="line">from table_name;</span><br></pre></td></tr></table></figure><h4 id="추출된-데이터-전송"><a href="#추출된-데이터-전송" class="headerlink" title="추출된 데이터 전송"></a>추출된 데이터 전송</h4><p>scp를 통해서 전송했었다.<br>참고로 나는 IDC경로가 달라서 로컬에 받은 후 이관하려는 서버로 scp전송했다.</p><h1 id="mysql에서의-작업"><a href="#mysql에서의-작업" class="headerlink" title="mysql에서의 작업"></a>mysql에서의 작업</h1><p>위 oracle 에서의 작업에서 table 생성 스크립트로 mysql에 table 생성이 되어있어야한다.</p><h4 id="Character-Set-변경"><a href="#Character-Set-변경" class="headerlink" title="Character Set 변경"></a>Character Set 변경</h4><p>테스트 해보니 한글이 깨지는 경우가 있어서 변경 해줘야 하는 것 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -c -f euc-kr -t utf-8 test.txt &gt; <span class="built_in">test</span>-utf8.txt</span><br></pre></td></tr></table></figure><h4 id="데이터-import"><a href="#데이터-import" class="headerlink" title="데이터 import"></a>데이터 import</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use theater;</span><br><span class="line"></span><br><span class="line">mysql&gt; LOAD DATA LOCAL INFILE '/oradata/migration/test_utf8.txt' </span><br><span class="line">INTO TABLE table_name</span><br><span class="line">FIELDS TERMINATED BY '|'</span><br><span class="line">IGNORE 1 LINES;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;사설&quot;&gt;&lt;a href=&quot;#사설&quot; class=&quot;headerlink&quot; title=&quot;사설&quot;&gt;&lt;/a&gt;사설&lt;/h1&gt;&lt;p&gt;2016년에 작업했던 기록 저장용&lt;br&gt;oracle &amp;gt; mysql 과 같이 이기종간 마이그레이션은 지원하는 몇가지 툴이 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GitLab설치 (Docker)</title>
    <link href="http://yoursite.com/2019/11/28/GitLab%EC%84%A4%EC%B9%98%20(Docker)/"/>
    <id>http://yoursite.com/2019/11/28/GitLab%EC%84%A4%EC%B9%98%20(Docker)/</id>
    <published>2019-11-28T05:05:30.384Z</published>
    <updated>2019-12-03T00:20:18.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="사설"><a href="#사설" class="headerlink" title="사설"></a>사설</h1><p>이전 포스팅에서는 GCP에 gitlab-ce를 설치해봤는데.<br>왜 docker를 사용하지 않았을까? 라는 생각을 해서<br>한번 시도해봤다.</p><p>이번 설치는 사내의 dev서버에서 진행했으며<br>설치된 gitlab-ce는 팀내 저장소 및 issue tracking으로 사용할 예정이다</p><h1 id="docker-설치-docker-compose-설치"><a href="#docker-설치-docker-compose-설치" class="headerlink" title="docker 설치 (docker-compose 설치)"></a>docker 설치 (docker-compose 설치)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum package update</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker install</span></span><br><span class="line">curl -fsSl https://get.docker.com/ | sudo sh</span><br></pre></td></tr></table></figure><h1 id="docker-compose-설치"><a href="#docker-compose-설치" class="headerlink" title="docker-compose 설치"></a>docker-compose 설치</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><h1 id="docker-compose-yml-파일-생성"><a href="#docker-compose-yml-파일-생성" class="headerlink" title="docker-compose.yml 파일 생성"></a>docker-compose.yml 파일 생성</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'gitlab/gitlab-ce:lastest'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'gitlab.example.com'</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">GITLAB_OMNIBUS_CONFIG:</span></span><br><span class="line">            <span class="string">external_url</span> <span class="string">'http://gitlab.example.com:8929'</span></span><br><span class="line">            <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">2224</span></span><br><span class="line">            <span class="comment"># smtp 설정 gmail</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_enable']</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_address']</span> <span class="string">=</span> <span class="string">'smtp.gmail.com'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_port']</span> <span class="string">=</span> <span class="number">587</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_user_name']</span> <span class="string">=</span> <span class="string">'thinkub0219@gmail.com'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_password']</span> <span class="string">=</span> <span class="string">'이메일 비밀번호'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_domain']</span> <span class="string">=</span> <span class="string">'smtp.gmail.com'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_authentication']</span> <span class="string">=</span> <span class="string">'login'</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_enable_starttls_auto']</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_tls']</span> <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">            <span class="string">gitlab_rails['smtp_openssl_verify_mode']</span> <span class="string">=</span> <span class="string">'peer'</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'8929:8929'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'2224:22'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'/home/gitlab/config:/etc/gitlab'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'/home/gitlab/logs:/var/log/gitlab'</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">'/home/gitlab/data:/var/opt/gitlab'</span></span><br></pre></td></tr></table></figure><ul><li>image : docker image 설정</li><li>restart : server restart시 해당 docker container 실행 여부</li><li>hostname : 사용하려는 hostname</li><li>enviroment : 설치되는 image의 설정<ul><li>해당 설정은 /etc/gitlab.gitlab.rb 에 들어갈 설정들에 대한 정의임</li></ul></li><li>ports : OSPort:dockerPort<ul><li>위 설정에서 보면 2224 포트는 Os port이고 해당 포트로 접근시 docker의 22번 port와 통신</li></ul></li><li>volumes : docker container 내부 volume과 OS간 연결 경로 <ul><li>앞이 OS 경로, 뒤가 Docker container경로</li></ul></li></ul><h1 id="docker-compose로-설치"><a href="#docker-compose로-설치" class="headerlink" title="docker-compose로 설치"></a>docker-compose로 설치</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>간혹 아래와 같은 오류를 만날 수 있다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Couldn<span class="string">'t connect to Docker daemon at http+docker://localhost - is it running?</span></span><br><span class="line"><span class="string">....</span></span><br></pre></td></tr></table></figure><p>도커 데몬이 안돌고 있다 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br><span class="line"></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: https://docs.docker.com</span><br></pre></td></tr></table></figure><p>dead 상태이니 running 상태로 바꿔보자</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="접속-확인"><a href="#접속-확인" class="headerlink" title="접속 확인"></a>접속 확인</h1><p>위 설정 한 External URL : port 정보로 접속을 해보면 접속이 잘된다.<br>로그인 계정은 <a href="mailto:admin@example.com" target="_blank" rel="noopener">admin@example.com</a> 으로 최초 로그인시 password를 입력하면 된다.</p><h1 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h1><p>Email이 발송되지 않는 문제가 있다.<br>흠 이래저래 해보는데 되지 않아서 이부분은 좀더 확인 후에 포스팅 할 예정이다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><blockquote><p>docs.gitlab.com/omnibus/docker<br>docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose<br>docs.docker.com/compose/install</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;사설&quot;&gt;&lt;a href=&quot;#사설&quot; class=&quot;headerlink&quot; title=&quot;사설&quot;&gt;&lt;/a&gt;사설&lt;/h1&gt;&lt;p&gt;이전 포스팅에서는 GCP에 gitlab-ce를 설치해봤는데.&lt;br&gt;왜 docker를 사용하지 않았을까? 라는 생각을 해서&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SonarQube를 이용한 코드리뷰 해보기</title>
    <link href="http://yoursite.com/2019/11/27/SonarQube%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0%20%ED%95%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>http://yoursite.com/2019/11/27/SonarQube%EB%A5%BC%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0%20%ED%95%B4%EB%B3%B4%EA%B8%B0/</id>
    <published>2019-11-27T03:35:40.230Z</published>
    <updated>2019-11-27T03:38:18.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="사설"><a href="#사설" class="headerlink" title="사설"></a>사설</h1><p>이전 회사에서 적용했던 sonaqube에 대해 정리한 내용이 있어서<br>블로그에 옮긴다.</p><h1 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube?"></a>SonarQube?</h1><p>SonarQube는 Java, C #, JavaScript, TypeScript, C / C ++, COBOL 등 20 개 이상의 프로그래밍 언어에서 버그, 코드 냄새? (code smells) 및 보안 취약성을 탐지하기 위해 코드의 정적 분석을 통해 자동 검토를 수행하는 오픈 소스 플랫폼입니다.<br>프로그램의 실제 실행 없이 코드를 분석하는 것</p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>돌아가기만 하면 되는 코드’는 개발자에게도, 프로젝트에도 전혀 도움이 되지 않습니다. 잘못된 코드는 또다른 잘못된 코드를 양상하고, 떨어지는 가독성과 높아지는 복잡도 덕분에 프로젝트 코드는 시간이 지남에 따라 점점 이해하기 힘든 모습이 되어갑니다. 개발자는 더 많은 노력과 시간이 필요해 지고, 프로젝트는 언제 터질지 모르는 폭탄을 품고 살아가게 됩니다.</p><p>때문에 프로그래밍에서도 잘못된 자세를 지적해 주고 제대로 개발 할 수 있도록 이끌어줄 방법들이 필요합니다. 개발자의 필수 도서라 불리는 책들은 몇번을 읽어도 손해 볼게 없습니다.</p><p>애자일 진영에서 강조하는 페어 프로그래밍, 몹 프로그래밍이나 코드 인스펙션 활동들 역시 좋은 대안이 될 수 있습니다. 이러한 문화를 이끌어 줄 수 있는 멘토가 있다면 빠른 시간내 코드의 품질이 좋아질 수 있습니다.<br>문제는 ‘사람 == 시간 == 돈’ 이기 때문에 제대로 된 개발을 위해서는 그만큼 많은 비용이 필요할 수 밖에 없습니다.</p><p>결국, 이러한 부분에 대한 고민 끝에, 비용이 추가로 들지 않으면서 코드의 품질을 검토하고 잘못된 부분을 옳은 방향으로 고칠 수 있도록 멘토링하는 다양한 도구들이 만들어졌습니다.</p><h1 id="SonarQube-1"><a href="#SonarQube-1" class="headerlink" title="SonarQube"></a>SonarQube</h1><p>SonarQube 플랫폼은 4개의 컴포넌트로 구성</p><ul><li>SonarQube Server</li><li>SonarQube Database</li><li>SonarQube Plugin</li><li>SonarQube Scanner<br><img src="/img/2019/11/27/20191127_01.png" alt="image01"></li></ul><h3 id="SonarQube-Server"><a href="#SonarQube-Server" class="headerlink" title="SonarQube Server"></a>SonarQube Server</h3><p>3가지의 메인 프로세스를 구동</p><ul><li>Web Server : 사용자들에게 분석 결과를 보여주고, SonarQube 설정 페이지를 제공합니다.</li><li>Search Server : Elasticsearch 서버를 사용하며, 사용자에게 검색기능을 제공합니다.</li><li>Compute Engine Server : 정적 분석 결과를 생성하고 이를 SonarQube Database를 통해 저장합니다.</li></ul><h3 id="SonarQube-Database"><a href="#SonarQube-Database" class="headerlink" title="SonarQube Database"></a>SonarQube Database</h3><p>SonarQube의 기본 설정들(보안, Plugin 정보 등)과 프로젝트 분석 스냅샷들을 저장합니다. 설치시, 기본으로 H2 DB를 포함하며, 설정을 통해 다양한 DB 사용이 가능합니다</p><h3 id="SonarQube-Plugin"><a href="#SonarQube-Plugin" class="headerlink" title="SonarQube Plugin"></a>SonarQube Plugin</h3><p>내부에서 사용하는 다양한 기능(분석 프로그램언어, 권한, 관리, SCM등)을 플러그인 형태로 설치 가능합니다.</p><h3 id="SonarQube-Scanner"><a href="#SonarQube-Scanner" class="headerlink" title="SonarQube Scanner"></a>SonarQube Scanner</h3><p>프로젝트 정적 분석을 수행하는 툴로 다양한 형식으로 제공되며 CI Server와 연계하여 사용이 가능합니다.</p><h1 id="SonarQube-Integration"><a href="#SonarQube-Integration" class="headerlink" title="SonarQube Integration"></a>SonarQube Integration</h1><p><img src="/img/2019/11/27/20191127_02.png" alt="image02"></p><ol><li>개발자는 IDE에서 코드를 작성하고, Sonar Lint등을 통해 로컬에서 코드 분석을 실행합니다.</li><li>개발자는 분석을 통해 수정된 완성코드를 SCM으로 Push 합니다.</li><li>CI 서버에서 트리거된 빌드 수행시 SonarQube Scanner를 실행합니다.</li><li>SonarQube Scanner는 생성한 분석 리포트의 처리를 위해 SonarQube로 전송합니다.</li><li>SonarQube Server는 분석 리포트 결과를 처리하여 DB에 저장하고 결과를 웹서버를 통해 제공합니다.</li><li>개발자는 웹페이지에서 분석결과를 확인하여 코드를 개선합니다.<br>관리자는 결과 보고서를 받습니다.</li><li>SonarQube에서 데이터를 추출하기위해 API를 활용하거나 SonarQube Server 모니터링을 위해 JMX를 사용할 수 있습니다</li></ol><h1 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h1><h3 id="Maven-설치"><a href="#Maven-설치" class="headerlink" title="Maven 설치"></a>Maven 설치</h3><p>기본적으로 Maven의 H2DB를 사용 &gt; SonarQube를 설치하기 전에 Maven부터 설치 해줘야 한다</p><h3 id="SonarQube-설치"><a href="#SonarQube-설치" class="headerlink" title="SonarQube 설치"></a>SonarQube 설치</h3><p>파일을 받아서 압축을 해제하면 끝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir sonar-qube</span><br><span class="line"><span class="built_in">cd</span> sonar-qube</span><br><span class="line">wget https://sonarsource.bintray.com/Distribution/sonarqube/sonarqube-6.7.5.zip</span><br><span class="line"></span><br><span class="line">unzip sonarqube-6.7.5.zip</span><br></pre></td></tr></table></figure><h3 id="SonarQube-Start"><a href="#SonarQube-Start" class="headerlink" title="SonarQube Start"></a>SonarQube Start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sonarqube-6.7.5/bin/linux-x86-64</span><br><span class="line">./sonar.sh start</span><br></pre></td></tr></table></figure><p>기본적으로 9000포트를 사용하고 있으니 다른 포트를 사용하려면 sonar.properties 수정하면된다.</p><h3 id="SonarQube-Scanner-설치"><a href="#SonarQube-Scanner-설치" class="headerlink" title="SonarQube Scanner 설치"></a>SonarQube Scanner 설치</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://sonarsource.bintray.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-3.0.3.778-linux.zip</span><br><span class="line"></span><br><span class="line">unzip sonar-scanner-cli-3.0.3.778-linux.zip</span><br></pre></td></tr></table></figure><h3 id="Jenkins-연동"><a href="#Jenkins-연동" class="headerlink" title="Jenkins 연동"></a>Jenkins 연동</h3><p>Jenkins 설치는 Skip</p><h3 id="Jenkins-Pluggin-설치"><a href="#Jenkins-Pluggin-설치" class="headerlink" title="Jenkins Pluggin 설치"></a>Jenkins Pluggin 설치</h3><ul><li>Python Plugin</li><li>GitHub Pull Request Builder</li><li>GitHub plugin</li><li>SonarQube Scanner for Jenkins</li></ul><p>SonarQube Scanner for Jenks 의 경우 Jenkins 버전체크를 해줘야 한다.<br><img src="/img/2019/11/27/20191127_03.png" alt="image03"></p><p>플러그인 설치가능 목록에 안나오는 경우가 있으니 이런 경우 아래 url 에서 Archives 를 받아서 올려도됨<br><a href="https://plugins.jenkins.io/sonar" target="_blank" rel="noopener">https://plugins.jenkins.io/sonar</a><br><img src="/img/2019/11/27/20191127_04.png" alt="image04"></p><h3 id="Jenkins-SonarQube-server-정보-등록"><a href="#Jenkins-SonarQube-server-정보-등록" class="headerlink" title="Jenkins SonarQube server 정보 등록"></a>Jenkins SonarQube server 정보 등록</h3><p>server url 정보에 sonarQube 서버 url 을 넣는다<br><img src="/img/2019/11/27/20191127_05.png" alt="image05"></p><h3 id="Server-authentication-token"><a href="#Server-authentication-token" class="headerlink" title="Server authentication token"></a>Server authentication token</h3><p>Server authentication token 은 sonarQube를 접속해서 admin (password : admin) 으로 접속하면 아래 화면처럼 생성 할 수 있다.<br><img src="/img/2019/11/27/20191127_06.png" alt="image06"></p><h3 id="Jenkins-SonarQube-scanner-정보-등록"><a href="#Jenkins-SonarQube-scanner-정보-등록" class="headerlink" title="Jenkins SonarQube scanner 정보 등록"></a>Jenkins SonarQube scanner 정보 등록</h3><p>jenkins &gt; configure tools<br><img src="/img/2019/11/27/20191127_07.png" alt="image07"></p><h3 id="Github과-Jenkins-연동"><a href="#Github과-Jenkins-연동" class="headerlink" title="Github과 Jenkins 연동"></a>Github과 Jenkins 연동</h3><p>SKIP</p><h3 id="어떻게-써볼까요"><a href="#어떻게-써볼까요" class="headerlink" title="어떻게 써볼까요?"></a>어떻게 써볼까요?</h3><ul><li>Jenkins Build 할때?</li><li>Pull Request 할때?</li><li>Local 에서?</li></ul><h3 id="Jenkins-Build-with-SonarQube"><a href="#Jenkins-Build-with-SonarQube" class="headerlink" title="Jenkins Build (with SonarQube)"></a>Jenkins Build (with SonarQube)</h3><p>Jenkins Sonar-scanner<br>Jenkins 에서 build 시 Sonar-scanner 설정법<br><img src="/img/2019/11/27/20191127_08.png" alt="image08"></p><h3 id="Pull-Request-with-SonarQube"><a href="#Pull-Request-with-SonarQube" class="headerlink" title="Pull Request (with SonarQube)"></a>Pull Request (with SonarQube)</h3><p><img src="/img/2019/11/27/20191127_09.png" alt="image09"><br>해당 구조를 사용하기 위해선 GitHub WebHook사용과 Jenkins에 2개의 Job이 필요하다</p><ul><li>Jenkins Job<ul><li>1번 job : pullrequest_receiver : github으로부터 web-hook을 통해 pullRequest정보를 받는 job</li><li>2번 job : sonaqube-job : 1번 job으로 부터 정보를 받아 SonarQube를 이용해 정적분석후 해당 pullRequest에 댓글로 리포팅 하는 Job</li></ul></li><li>GitHub WebHook<ul><li>Github에서 Jenkins Job을 호출하기 위해서는 Jenkins가 외부에 공개되어 있어야 한다</li></ul></li></ul><h3 id="SonarLint-IntelliJ"><a href="#SonarLint-IntelliJ" class="headerlink" title="SonarLint (IntelliJ)"></a>SonarLint (IntelliJ)</h3><p>위와 같은 방법으로 SonarQube를 사용한다면…<br>코드를 작성하고 commit / push 이후에나 정적분석 피드백을 받을 수 있다.</p><h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><p>Setting &gt; plugins &gt; Search in repositories<br>SonarLint 검색<br><img src="/img/2019/11/27/20191127_10.png" alt="image10"></p><h4 id="SonarQube-서버-연동"><a href="#SonarQube-서버-연동" class="headerlink" title="SonarQube 서버 연동"></a>SonarQube 서버 연동</h4><p>기본적인 설정만으로도 충분히 사용할 수 있으며 sonarqube 서버가 없어도 사용에 문제가 없습니다.<br>setting &gt; Other Settings &gt; SonarLing General Settings<br><img src="/img/2019/11/27/20191127_11.png" alt="image11"></p><p>참고</p><blockquote><p><a href="https://www.sonarqube.org/about/" target="_blank" rel="noopener">https://www.sonarqube.org/about/</a><br><a href="http://lazyrodi.github.io/2017/02/06/2017-02-06-etc-install-sonarqube/" target="_blank" rel="noopener">http://lazyrodi.github.io/2017/02/06/2017-02-06-etc-install-sonarqube/</a><br><a href="https://medium.com/@cgpink/소스-정적-분석도구-sonarqube-리서칭-9d48fc62b01f" target="_blank" rel="noopener">https://medium.com/@cgpink/소스-정적-분석도구-sonarqube-리서칭-9d48fc62b01f</a><br><a href="https://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/" target="_blank" rel="noopener">https://www.popit.kr/내코드를-자동으로-리뷰해준다면-by-sonarqube/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;사설&quot;&gt;&lt;a href=&quot;#사설&quot; class=&quot;headerlink&quot; title=&quot;사설&quot;&gt;&lt;/a&gt;사설&lt;/h1&gt;&lt;p&gt;이전 회사에서 적용했던 sonaqube에 대해 정리한 내용이 있어서&lt;br&gt;블로그에 옮긴다.&lt;/p&gt;
&lt;h1 id=&quot;SonarQu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GitLab설치 (GCP)</title>
    <link href="http://yoursite.com/2019/11/26/GitLab%EC%84%A4%EC%B9%98%20(GCP)/"/>
    <id>http://yoursite.com/2019/11/26/GitLab%EC%84%A4%EC%B9%98%20(GCP)/</id>
    <published>2019-11-26T04:18:30.667Z</published>
    <updated>2019-12-02T09:10:10.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="사설"><a href="#사설" class="headerlink" title="사설"></a>사설</h1><p>최근 이직을 했는데.<br>이전 회사는 웹서비스를 하는 회사였고, 이직한 회사는 AI 하는 회사였다<br>물론 내가 담당한 업무는 웹개발이라서 업무가 달라지진 않았지만 환경이 달랐다</p><p>이전 회사는 모기업의 영향을 받아 Issue관리는 자체개발 솔루션을 사용했고<br>SCM은 git enterprise를 사용하는 등 나름 괜찮은 환경이었다.</p><p>이직한 회사는 svn을 사용하고 Issue관리는 그냥 메일로 하고,<br>IntelliJ 도 개인라이선스를 구매하는 등. 좀 열악한 편이었다.</p><p>그 중 제일 불편한게 Issue관리!!<br>메일로 주고 받다 보니 이런 저런 메일이 오면서 History추적이 어려웠다.</p><h1 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h1><p>예전 N사와 API 연동 작업을 한적이 있는데.<br>이때 Gitlab을 이용해서 Issue관리를 했었다.<br>상당히 괜찮았던 기억이 있어서 Gitlab을 설치해보기로 했다.</p><h3 id="어디에-설치하지"><a href="#어디에-설치하지" class="headerlink" title="어디에 설치하지?!"></a>어디에 설치하지?!</h3><p>아직 회사에다가 내가 Gitlab을 설치하고 싶으니 서버를 주세요.<br>라고 말하기가 어려운 상태다 (아직 이직 1달이 되지 않았다 ㅠ)<br>aws가 1년간 무료이니 거기에 설치해 보려했으나….<br>aws프리티어 인스턴스를 만들다 보면 지원되는 CPU와 메모리가 1core 에 1GB이다.<br>gitlab의 경우 최소 2core CPU와 4GB의 RAM을 권장한다.<br>혹시나 하는 마음에 aws에 설치해 봤으나 아래와 같은 문구를 만나게 되었다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot allocate memory - fork(2)</span><br></pre></td></tr></table></figure><p>그래서 선택한건 구글 클라우드.<br>구글 클라우드의 경우 무료 크레딧($300)을 준 다음.<br>해당 크레딧을 사용하는 한도에서는 어떤 스펙의 장비를 써도 된다.</p><h1 id="GCP-Compute-Engine"><a href="#GCP-Compute-Engine" class="headerlink" title="GCP Compute Engine"></a>GCP Compute Engine</h1><ol><li><p>google cloud platform 사이트에 로그인 후 Compute Engine선택<br><img src="/img/2019/11/26/20191126_01.png" alt="image01"></p></li><li><p>VM 인스턴스 만들기<br><img src="/img/2019/11/26/20191126_02.png" alt="image02"></p></li><li><p>옵션 선택 (옵션 선택에 따른 비용이 달라진다 오른쪽에 표시)</p><ul><li>이름 : 사용하고자 하는 서버명을 적는다 나는 gitlab을 적었다.</li><li>리전 : 리전에 따라 사용비용이 다르다. 이건 개인 취향으로.</li><li>영역 : 그냥 Defalut로</li><li>시리즈 : N1 선택 이것도 선택에 따라 비용이 달라진다.<br>(N2의 경우 최소사양이 CPU 2, 8GB메모리라 N1을 선택했다.)</li><li>머신유형 : 최소사양으로 해보았다. CPU 2개, 7.5GB</li><li>그외 : 기본을 사용하고 HTTP, HTTPS 트래픽 허용<br><img src="/img/2019/11/26/20191126_03.png" alt="image03"></li></ul></li><li><p>만들기를 누르기전 OS이미지를 선택하자</p><ul><li>옵션 중 부팅디스크의 변경 선택</li><li>Ubuntu 16.04 LTS를 선택한다.</li><li>SSD 영구디스크를 선택하고 크기는 40GB정도로 잡는다.<br><img src="/img/2019/11/26/20191126_04.png" alt="image04"></li></ul></li></ol><h1 id="Gitlab-설치"><a href="#Gitlab-설치" class="headerlink" title="Gitlab 설치"></a>Gitlab 설치</h1><p>방금 생성한 Instance에 Gitlab을 설치해보자<br><img src="/img/2019/11/26/20191126_05.png" alt="image05"></p><ol><li>ssh버튼을 누르면 콘솔창이 열린다.<br><img src="/img/2019/11/26/20191126_06.png" alt="image06"></li></ol><ol start="2"><li><p>필요한 Dependency를 설치 및 Update</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y curl openssh-server ca-certificates</span><br></pre></td></tr></table></figure></li><li><p>Gitlab 패키지 Repository 추가 및 패키지 설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure></li><li><p>저장소 목록 업데이트</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>Gitlab CE설치</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gitlab-ce</span><br></pre></td></tr></table></figure><ul><li>설치가 완료되면 아래와 같은 로고가 보인다.<br><img src="/img/2019/11/26/20191126_07.png" alt="image07"></li></ul></li></ol><ol start="6"><li>Gitlab 초기설정<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li></ol><h1 id="Gitlab-설정"><a href="#Gitlab-설정" class="headerlink" title="Gitlab 설정"></a>Gitlab 설정</h1><p>Gitlab 관련 설정파일은 /etc/gitlab.gitlab.rb 파일에서 할 수 있다.<br>external_url 만 바꿔 보겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure><p>설정 완료후 설정 적용 및 재시작을 해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><h1 id="접속테스트"><a href="#접속테스트" class="headerlink" title="접속테스트"></a>접속테스트</h1><p><img src="/img/2019/11/26/20191126_08.png" alt="image08"></p><h1 id="참고-Site"><a href="#참고-Site" class="headerlink" title="참고 Site"></a>참고 Site</h1><blockquote><p>docs.gitlab.com/ce/install/google_cloud_platform<br>docs.gitlab.com/ce/README.html</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;사설&quot;&gt;&lt;a href=&quot;#사설&quot; class=&quot;headerlink&quot; title=&quot;사설&quot;&gt;&lt;/a&gt;사설&lt;/h1&gt;&lt;p&gt;최근 이직을 했는데.&lt;br&gt;이전 회사는 웹서비스를 하는 회사였고, 이직한 회사는 AI 하는 회사였다&lt;br&gt;물론 내가 담당한 업
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>mongo DB설치하기 (Feat. Docker)</title>
    <link href="http://yoursite.com/2019/11/25/mongo%20DB%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0%20(Feat.%20Docker)/"/>
    <id>http://yoursite.com/2019/11/25/mongo%20DB%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0%20(Feat.%20Docker)/</id>
    <published>2019-11-25T04:05:04.135Z</published>
    <updated>2019-11-26T04:13:12.020Z</updated>
    
    <content type="html"><![CDATA[<p>일전에 프로젝트 하나를 진행하게 되었는데.<br>DB의 로우데이터를 특정 조건에 맞게 집계를 해야했다.<br>프로젝트 규모나 사용성을 봤을때는<br>rdbms로 작업해도 크게 무리가 되지 않는 스펙이었다<br>근데 주변 동료들이 no-sql로 하는건 어떠냐고 해서 한번 해보기로 했다.</p><h1 id="DB-선택하기"><a href="#DB-선택하기" class="headerlink" title="DB 선택하기"></a>DB 선택하기</h1><p>먼저 어떤 db engine이 가장 많이 사용되는지 검색해 봤다<br><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">여기</a> 에서 확인 해보니 Document 기반으로는 MongoDB 순위가 높았다<br>통계 Data 특성상 스키마간 RelationShip이 크게 필요하지 않을 것이라 생각해서 MongoDB로 해보기로 했다<br><img src="/img/docker-mongo1.png" width="700px" ></img></p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB ?"></a>MongoDB ?</h1><blockquote><p>MongoDB는 필요한 쿼리 및 인덱싱을 통해 원하는 확장성과 유연성을 갖춘 문서 데이터베이스입니다.</p></blockquote><ul><li>MongoDB는 데이터를 유연한 JSON 형식의 문서로 저장합니다. 즉, 필드마다 문서마다 다를 수 있으며 시간이 지남에 따라 데이터 구조가 변경 될 수 있습니다.</li><li>문서 모델은 응용 프로그램 코드의 개체에 매핑되므로 데이터를 쉽게 사용할 수 있습니다.</li><li>임시 질의, 인덱싱 및 실시간 집계는 데이터 액세스 및 분석을위한 강력한 방법을 제공합니다.</li><li>MongoDB는 핵심적인 분산 데이터베이스이므로 고 가용성, 수평 확장 및 지리적 분포가 내장되어 사용하기 쉽습니다.</li><li>MongoDB는 무료이며 오픈 소스이며, GNU Affero General Public License</li></ul><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ol><li>Document-oriented storage : MongoDB는 database &gt; collections &gt; documents 구조로 document는 key-value형태의 BSON(Binary JSON)으로 되어있다</li><li>Full Index Support : 다양한 인덱싱을 제공한다.<ol><li>Single Field Indexes : 기본적인 인덱스 타입</li><li>Compound Indexes : RDBMS의 복합인덱스 같은 거</li><li>Multikey Indexes : Array에 매칭되는 값이 하나라도 있으면 인덱스에 추가하는 멀티키 인덱스</li><li>Geospatial Indexes and Queries : 위치기반 인덱스와 쿼리</li><li>Text Indexes : String에도 인덱싱이 가능</li><li>Hashed Index : Btree 인덱스가 아닌 Hash 타입의 인덱스도 사용 가능</li></ol></li><li>Replication&amp; High Availability : 간단한 설정만으로도 데이터 복제를 지원. 가용성 향상</li><li>Auto-Sharding : MongoDB는 처음부터 자동으로 데이터를 분산하여 저장하며, 하나의 컬렉션처럼 사용할 수 있게 해준다. 수평적 확장 가능</li><li>Querying(documented-based query) : 다양한 종류의 쿼리문 지원. (필터링, 수집, 정렬, 정규표현식 등)</li><li>Fast In-Pace Updates : 고성능의 atomic operation을 지원</li><li>Map/Reduce : 맵리듀스를 지원.(map과 reduce 함수의 조합을 통해 분산/병렬 시스템 운용 지원, 하둡처럼 MR전용시스템에 비해서는 성능이 떨어진다)</li><li>GridFS : 분산파일 저장을 MongoDB가 자동으로 해준다. 실제 파일이 어디에 저장되어 있는지 신경 쓸 필요가 없고 복구도 자동이다.</li><li>Commercial Support : 10gen에서 관리하는 오픈소스</li></ol><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ol><li>Flexibility : Schema-less라서 어떤 형태의 데이터라도 저장할 수 있다.</li><li>Performance : Read &amp; Write 성능이 뛰어나다. 캐싱이나 많은 트래픽을 감당할 때 써도 좋다.</li><li>Scalability : 애초부터 스케일아웃 구조를 채택해서 쉽게 운용가능하다. Auto sharding 지원</li><li>Deep Query ability : 문서지향적 Query Language 를 사용하여 SQL 만큼 강력한 Query 성능을 제공한다.</li><li>Conversion / Mapping : JSON형태로 저장이 가능해서 직관적이고 개발이 편리하다.</li></ol><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h3><ol><li>정합성이 떨어지므로 트랜잭션이 필요한 경우에는 부적합하다. (ex. 금융, 결제, 회원정보 등)</li><li>JOIN이 없다. join이 필요없도록 데이터 구조화 필요</li><li>memory mapped file으로 파일 엔진 DB이다. 메모리 관리를 OS에게 위임한다. 메모리에 의존적, 메모리 크기가 성능을 좌우한다. 2-4를 참고하자.</li><li>SQL을 완전히 이전할 수는 없다.</li><li>B트리 인덱스를 사용하여 인덱스를 생성하는데, B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 저하된다. 이런 B트리의 특성 때문에 데이터를 넣어두면 변하지않고 정보를 조회하는 데에 적합하다.</li></ol><h1 id="MongoDB-설치-Feat-Docker"><a href="#MongoDB-설치-Feat-Docker" class="headerlink" title="MongoDB 설치 (Feat. Docker)"></a>MongoDB 설치 (Feat. Docker)</h1><p>사전 설치 서버에 Docker설치를 해야한다.<br>이전 회사 특성상 root권한이 없었기에 관리자에게 설치 요청</p><h3 id="Image-Download"><a href="#Image-Download" class="headerlink" title="Image Download"></a>Image Download</h3><p>필요한 Image는 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 에서 검색이 가능하다</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><p>Download 된 이미지 확인</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="Image-생성"><a href="#Image-생성" class="headerlink" title="Image 생성"></a>Image 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mongo:tl_mongo .</span><br></pre></td></tr></table></figure><h3 id="Container-생성"><a href="#Container-생성" class="headerlink" title="Container 생성"></a>Container 생성</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 27017:27017 -v /home1/irteam/mongo/data:/data/db --name ubuntu --net=host -e MONGO_INITDB_ROOT_USERNAME=id입력부분 -e MONGO_INITDB_ROOT_PASSWORD=<span class="built_in">pwd</span>입력부분 mongo --auth--auth</span><br></pre></td></tr></table></figure><h3 id="인증모드로-mongo접속"><a href="#인증모드로-mongo접속" class="headerlink" title="인증모드로 mongo접속"></a>인증모드로 mongo접속</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &#123;containerId&#125; mongo -u id입력부분 -p <span class="built_in">pwd</span>입력부분 -authenticationDatabase admin</span><br></pre></td></tr></table></figure><ul><li><p>admin 계정 생성후 사용계정 별도 생성</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use 생성DB명</span><br><span class="line"></span><br><span class="line">db.createUser(</span><br><span class="line">    &#123;</span><br><span class="line">        user: mongoDB유저ID,</span><br><span class="line">        <span class="built_in">pwd</span>: mongoDB유저PWD,</span><br><span class="line">        roles: [</span><br><span class="line">            &#123;</span><br><span class="line">                role: <span class="string">"readWrite"</span>,</span><br><span class="line">                db: 생성DB명</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>생성된 계정으로 접속</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 컨테이너ID mongo -u mongoDB유저ID -p mongoDB유저PWD -authenticationDatabase 생성DB명</span><br></pre></td></tr></table></figure></li></ul><h3 id="MongoDB-Compass"><a href="#MongoDB-Compass" class="headerlink" title="MongoDB Compass"></a>MongoDB Compass</h3><p>워크벤치나 토드같은 client 도구이다<br><a href="https://www.mongodb.com/download-center/compass" target="_blank" rel="noopener">https://www.mongodb.com/download-center/compass</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;일전에 프로젝트 하나를 진행하게 되었는데.&lt;br&gt;DB의 로우데이터를 특정 조건에 맞게 집계를 해야했다.&lt;br&gt;프로젝트 규모나 사용성을 봤을때는&lt;br&gt;rdbms로 작업해도 크게 무리가 되지 않는 스펙이었다&lt;br&gt;근데 주변 동료들이 no-sql로 하
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring-boot War 배포</title>
    <link href="http://yoursite.com/2019/11/22/Spring-boot%20War%20%EB%B0%B0%ED%8F%AC/"/>
    <id>http://yoursite.com/2019/11/22/Spring-boot%20War%20%EB%B0%B0%ED%8F%AC/</id>
    <published>2019-11-22T06:24:58.395Z</published>
    <updated>2019-11-22T06:43:12.423Z</updated>
    
    <content type="html"><![CDATA[<p>아주 간단한 프로젝트 진행요청이 왔다.<br>간단히 spring-boot로 프로젝트를 생성해서 진행을 했다<br>결과물을 전달하려고 하는데 war파일로 달라는거다</p><h1 id="pom-xml-설정"><a href="#pom-xml-설정" class="headerlink" title="pom.xml 설정"></a>pom.xml 설정</h1><h3 id="packaging-설정"><a href="#packaging-설정" class="headerlink" title="packaging 설정"></a>packaging 설정</h3><p>보통 spring-boot 로 프로젝트를 만들면 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>로 되어있거나 해당 설정 부분이 없는 경우도 있다 <br><br>이 부분을 아래와 같이 수정해준다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="톰켓-배포용-라이브러리-dependency-추가"><a href="#톰켓-배포용-라이브러리-dependency-추가" class="headerlink" title="톰켓 배포용 라이브러리 dependency 추가"></a>톰켓 배포용 라이브러리 dependency 추가</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="SpringBootServletInitialLizer-작성"><a href="#SpringBootServletInitialLizer-작성" class="headerlink" title="SpringBootServletInitialLizer 작성"></a>SpringBootServletInitialLizer 작성</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitiallizer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder applicationBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationBuilder.sources(DocHelperApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>끗</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;아주 간단한 프로젝트 진행요청이 왔다.&lt;br&gt;간단히 spring-boot로 프로젝트를 생성해서 진행을 했다&lt;br&gt;결과물을 전달하려고 하는데 war파일로 달라는거다&lt;/p&gt;
&lt;h1 id=&quot;pom-xml-설정&quot;&gt;&lt;a href=&quot;#pom-xml-설정&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>github 블로그만들기 (Feat. hexo)</title>
    <link href="http://yoursite.com/2019/11/21/github%20%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A7%8C%EB%93%A4%EA%B8%B0%20(Feat.hexo)/"/>
    <id>http://yoursite.com/2019/11/21/github%20%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A7%8C%EB%93%A4%EA%B8%B0%20(Feat.hexo)/</id>
    <published>2019-11-21T08:50:12.743Z</published>
    <updated>2019-12-02T05:31:46.064Z</updated>
    
    <content type="html"><![CDATA[<p>기억력이 좋지 못해서, 무언가 알게된 지식을 기존엔 evernote에 저장을 했었다.<br>차곡차곡 문서가 쌓이다보니…. 뭘 작성한지도 작성한걸 찾지도 못하는 나를 발견하여<br>느지막이 github 블로그를 만들어 보기로 결심. hexo를 이용해보기로 했다.</p><h1 id="github-repository-생성"><a href="#github-repository-생성" class="headerlink" title="github repository 생성"></a>github repository 생성</h1><ul><li>repository 명칭은 USERNAME.github.io 로 생성 (thinkub.github.io)</li><li>Description 은 마음데로</li><li>public 설정하고</li><li>README 파일은 생성한다.<br>  <img src="/img/screenshot01.png" width="500px" ></img></li></ul><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><ul><li><p>git clone<br>먼저 생성한 blog용 git repository를 clone한다</p></li><li><p>hexo 설치<br><img src="/img/hexo01.png" width="500px" ></img></p><ul><li><p>clone 한 경로에 blog 라는 폴더로 hexo 를 init</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></li><li><p>첨부된 이미지 처럼 blog 라는 경로가 생김<br><img src="/img/hexo02.png" width="200px" ></img>   </p></li><li><p>local 에서 확인하기</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="/img/hexo04.png" width="100%" ></img></p></li></ul></li><li><p>theme 적용<br><a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">여기</a> 에서 원하는 걸 고르면된다.<br>나는 <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank" rel="noopener">clean-blog</a> 를 사용하기로 했음</p><ul><li><p>선택한 theme repository git clon<br><img src="/img/hexo05.png" width="100%" ></img></p></li><li><p>theme 적용<br><img src="/img/hexo06.png" width="100%" ></img></p></li></ul></li><li><p>github 동기화</p><ul><li><p>/blog/_config.yml 파일을 보면 Deploy 설정하는 곳이 있다 여기에 설정<br><img src="/img/hexo07.png" width="100%" ></img></p></li><li><p>public 파일 변환<br><img src="/img/hexo08.png" width="100%" ></img></p></li><li><p>git에 올리기</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;기억력이 좋지 못해서, 무언가 알게된 지식을 기존엔 evernote에 저장을 했었다.&lt;br&gt;차곡차곡 문서가 쌓이다보니…. 뭘 작성한지도 작성한걸 찾지도 못하는 나를 발견하여&lt;br&gt;느지막이 github 블로그를 만들어 보기로 결심. hexo를 이용
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
